[
  {
    "path": "posts/2021-03-11-manipolazione-dei-dati-con-dplyr/",
    "title": "Manipolazione dei dati con dplyr",
    "description": "Tutorial sull'uso delle funzionalit√† di base di dplyr per la manipolazione dei dati.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-11",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nAggiungo qui il link ad un video-tutorial che ho preparato relativamente alla manipolaizone dei dati usando le funzioni del pacchetto dplyr.\nNel video non faccio altro che commentare un tutorial predisposto da Allison Horst e disponibile seguendo questo link. Il tutorial di Allison Horst √® fatto benissimo e non vedo ragioni di tradurlo o cambiarlo in qualche modo. Inoltre, se andate nella pagina web che ho indicato sopra, potete anche fare degli esercizi che vi consentono di verificare se avete capito come utilizzare in pratica le istruzioni R che vengono discusse ‚Äì le risposte agli esercizi sono immediatamente disponibili il che rende il tutorial di Allison Horst un utilissimo strumento di apprendimento. Buon divertimento!\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-11T08:27:48+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-10-introduzione-a-r-markdown/",
    "title": "Introduzione a R Markdown",
    "description": "Creare un documento R Markdown con R Studio.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-10",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nPosto qui il link ad un breve video-tutorial sull‚Äôuso di R Markdown.\nPu√≤ anche risultare utile la lettura del seguente documento.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-10T22:09:52+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-10-notazione-sommatoria/",
    "title": "Notazione sommatoria",
    "description": "Simbolo di somma.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-10",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nLa notazione delle sommatorie √® molto utilizzata nell‚Äôanalisi dei dati per cui √® necessario familiarizzarsi con essa. Questo argomento √® trattato nell‚Äôappendice delle dispense, oppure su Wikipedia (https://it.wikipedia.org/wiki/Sommatoria).\nPer evitare errori di calcolo, possiamo usare R per risolvere questo tipo di problemi, il che ci fornisce anche la possibilit√† di fare un po‚Äô di esercizi sui vettori. I vettori sono semplicemente un insieme ordinato di dati. Solitamente corrispondono a quello che chiamiamo variabile, ovvero ci√≤ che uno psicologo misura e vuole descrivere o analizzare in qualche modo. Per esempio, una variabile pu√≤ corrispondere al QI di un insieme di individui. Abbiamo visto che, in R, possiamo definire questo insieme di dati (che si chiama vettore) usando la funzione c().\nSupponiamo di avere misurato il QI di 5 persone e di avere ottenuto i risultati seguenti: 102, 98, 122, 109, 89.\nPer manipolare questi dati, dobbiamo prima renderli disponibili nel workspace della sessione di R:\n\n\nx <- c(102, 98, 122, 109, 89)\nx\n\n\n[1] 102  98 122 109  89\n\nSe usiamo la notazione di sommatoria per questi dati nella forma seguente\n\\[\n\\sum_{i = 1}^5 x_i\n\\]\nci√≤ significa somma tutti i valori x che hanno l‚Äôindice che va da 1 a 5. Se sviluppiamo la notazione precedente, per i dati dell‚Äôesempio avremo\n\\[\n\\sum_{i = 1}^5 x_i = x_1 + x_2 + x_3 + x_4 + x_5\n\\]\nladdove\n\\[\nx_1 = 102 \\quad x_2 = 98 \\quad x_3 = 122 \\quad x_4 = 109 \\quad x_5 = 89.\n\\]\nIn R una sommatoria si svolge utilizzando la funzione sum(). Quindi, nel caso presente, la somma\n\\[\n\\sum_{i = 1}^{n=5} x_i\n\\]\nin R diventa\n\n\nsum(x)\n\n\n[1] 520\n\nLa notazione della sommatoria viene utilizzata, per esempio, nel calcolo della media:\n\\[\n\\bar{x} = \\frac{\\sum_{i = 1}^{n} x_i}{n}\n\\]\nNella formula precedente, sommiamo prima i valori contenuti nel vettore x e poi dividiamo il risultato ottenuto per n = 5, ovvero 520 / 5 = 104.\nIn R abbiamo\n\n\nsum(x) / length(x)\n\n\n[1] 104\n\nladdove la funzione length(x) ci restituisce i numero di elementi che costituiscono il vettore x, ovvero 5.\nIn maniera equivalente, per le propriet√† delle sommatorie, la formula della media pu√≤ essere scritta come\n\\[\n\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^{n} x_i = \\sum_{i = 1}^{n}\\frac{1}{n} x_i,\n\\]\nil che significa che possiamo prima moltiplicare ciascun elemento di x per 1/n e poi sommare, come indicato qui di seguito:\n\\[\n(1/5 \\times 102) + (1/5 \\times 98) + (1/5 \\times  122) + (1/5 \\times  109) + (1/5 \\times  89)\n\\]\nIn R questo diventa\n\n\nsum(1/5 * x)\n\n\n[1] 104\n\nperch√©\n\n\n1/5 * x\n\n\n[1] 20.4 19.6 24.4 21.8 17.8\n\ncorrisponde al vettore\n\\[\n(1/5 \\times 102) + (1/5 \\times 98) + (1/5 \\times  122) + (1/5 \\times  109) + (1/5 \\times  89)\n\\]\ndopodich√© sommiamo utilizzando la funzione sum().\nLa cosa importante da ricordare √® che le operazioni algebriche (in questo caso moltiplicare per 1/5), quando vengono applicate ad un vettore (nel nostro caso (102, 98, 122, 109, 89)) si calcolano elemento per elemento. Ovvero, a ciascun elemento viene applicata l‚Äôoperazione algebrica indicata, cio√® il valore 102 viene moltiplicato per 1/5, il valore 98 viene moltiplicato per 1/5, ecc.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-10T22:05:49+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-1/",
    "title": "Introduzione a R (1)",
    "description": "Il primo di una serie di post che presentano la sintassi di base di R.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nSintassi\n√à difficile sapere da dove iniziare quando si deve imparare un nuovo linguaggio di programmazione. Questi file Rmd hanno lo scopo di fornire qualche informazione di base che spero possa dare un‚Äôidea generale di come R viene usato.\nCi sono approcci diversi per imparare un linguaggio di programmazione come R. L‚Äôapproccio meno efficiente √® quello che ci porta a cercare le informazioni a proposito della sintassi di R quando ci servono per risolvere un problema specifico. Questo approccio √® motivato dal fatto che non √® molto divertente studiare la sintassi di un linguaggio di programmazione in termini astratti. Questo √® l‚Äôapproccio che seguo io. Per cui, secondo me, il modo migliore per imparare la sintassi di R √® quello di‚Ä¶ usare R e cercare con Google la soluzione di ciascuno specifico problema di sintassi, quando esso si presenta.\nL‚Äôapproccio pi√π tradizionale (e molto pi√π efficiente) √® invece quello di leggere un manuale in cui tutto viene presentato in maniera sistematica. √à facilissimo trovare in rete un enorme numero di guide all‚Äôutilizzo dell‚Äôambiente statistico R. Uno dei punti di entrata in questo mondo √® sicuramente il testo scritto da Hadley Wickham: R for Data Science. Pu√≤ anche essere utile e/o divertente leggere i messaggi twitter che utilizzano l‚Äôhashtag #rstats.\nR: linguaggio + ambiente\nR √® un port al linguaggio S, sviluppata presso i Bell Labs. R √® open source e gratuito da utilizzare e distribuire. Pu√≤ essere installato e utilizzato sui principali sistemi operativi.\nR pu√≤ essere inteso come un linguaggio e un ambiente integrati che sono stati progettati avendo come finalit√† il calcolo statistico e l‚Äôanalisi dei dati. A tal fine, la sua struttura rappresenta un compromesso tra una base di codice he √® stata ottimizzata per le procedure matematiche sopra la quale sono state sviluppate funzionalit√† di alto livello che possono essere utilizzate in modo interattivo. In altre parole, √® un ottimo strumento per lavorare in modo interattivo con dati quantitativi.\nLe funzionalit√† di R si stanno estendendo sempre pi√π attraverso pacchetti forniti dagli utenti. Useremo un certo numero di pacchetti in questo insegnamento, soprattutto quelli sviluppati all‚Äôinterno della famiglia tidyverse.\nRStudio: Ambiente di sviluppo integrato (IDE) per R\nRStudio fa quasi tutto ci√≤ che √® pu√≤ essere fatto con R, in maniera pi√π semplice. Quindi √® un ottimo programma completo per l‚Äôutilizzo di R. Lo consiglio vivamente.\nAssegnazione\nIn R, qualcunque cosa √® un oggetto. Gli oggetti sono come scatole in cui possiamo mettere le cose: dati, funzioni e persino altri oggetti.\nPrima di discutere i tipi di dati e le strutture, il primo argomento che presenteremo relativamente alla sintassi di R √® come assegnare valori agli oggetti. In R, il mezzo principale di assegnazione √® la freccia, <-, che √® un simbolo minore di <, seguito da un trattino, -.\n\n\nx <- 3\nx\n\n\n[1] 3\n\ne anche\n\n\ny <- \"estate\"\ny\n\n\n[1] \"estate\"\n\nR usato come un calcolatore\nR pu√≤ essere usato come qualunque calcolatore portatile. Avendo a disposizione un computer √® ridicolo usare un calcolatore portatile. All‚Äôesame, molti studenti si ostinano ad usare uno smartphone per fare i calcoli. Credetemi, √® molto pi√π facile fare i calcoli usando R su un computer!\nLe operazioni algebriche si svolgono nel modo seguente:\n\n\n5 + 2\n\n\n[1] 7\n\n7 - 3\n\n\n[1] 4\n\n10 * 3\n\n\n[1] 30\n\n21 / 3\n\n\n[1] 7\n\nx^2\n\n\n[1] 9\n\nsqrt(9)\n\n\n[1] 3\n\nEsecuzione di comandi in R\nTre modi per eseguire i comandi in R\nUsare la console.\nDigitare / copiare i comandi direttamente nella ‚Äúconsole‚Äù (non una buona idea, a meno che facciamo qualcosa di estremamente semplice e non ci interessa salvare il procedimento).\nUsare uno script R (file .R).\nUno script R pu√≤ essere creato in RStudio mediante il menu a tendina File > New File > R Script. Pu√≤ essere salvato come un qualunque altro file e pu√≤ essere riutilizzato e modificato in un secondo momento. √à possibile eseguire un comando alla volta, pi√π comandi alla volta o l‚Äôintero script. - Cmd / Ctrl + Invio: esegue le linee evidenziate - Cmd / Ctrl + Maiusc + Invio (senza evidenziare alcuna riga): esegue l‚Äôintero script.\nUsare un file RMarkdown (file .Rmd).\nI file RMarkdown possono essere creati in RStudio mediante il menu a tendina File > New File > R Notebook. Un file RMarkdown √® costituito da diversi ‚Äúcode chunks‚Äù. √à possibile eseguire un comando alla volta, un blocco alla volta o eseguire ‚Äúknit‚Äù sull‚Äôintero documento. - Cmd / Ctrl + Invio: esegue le linee evidenziate all‚Äôinterno del blocco - Cmd / Ctrl + Shift + k: ‚Äúknit‚Äù per l‚Äôintero documento\nOggetti\nR √® un linguaggio di programmazione ‚Äúobject-oriented‚Äù (come Python). Ma cos‚Äô√® un ‚Äúoggetto‚Äù?\nIntuitivamente, possiamo pensare che gli oggetti siano qualcosa a cui vengono assegnati dei valori.\n\n\na <- 5\na\n\n\n[1] 5\n\nb <- \"eil√†!\"\nb\n\n\n[1] \"eil√†!\"\n\n\nObjects are like boxes in which we can put things: data, functions, and even other objects.\n\nSi noti che per assegnare un numero all‚Äôoggetto a abbiamo digitato il numero a sinistra dell‚Äôoperatore di assegnazione. Nel caso di una stringa, invece, √® stato necessario scrivere la serie di simboli alfanumerici tra virgolette.\nNon c‚Äô√® limite al numero di oggetti che R pu√≤ contenere (tranne la memoria).\nClassi di oggetti\nGli oggetti possono essere categorizzati in base alle categorie ‚Äútype‚Äù e ‚Äúclass‚Äù.\nAd esempio, una data √® un oggetto con type numerico e una class ‚Äúdate‚Äù;\nun dataset √® un oggetto con specifiche caratteristiche type e class.\nVettori\nL‚Äôoggetto fondamentale in R √® il vettore\nUn vettore √® un insieme di valori.\nI singoli valori all‚Äôinterno di un vettore sono chiamati ‚Äúelementi‚Äù.\nI valori in un vettore possono essere numerici o possono essere delle stringhe alfanumeriche (ad esempio ‚ÄúPomodoro‚Äù) o appartenenti ad altre classi type.\nDi seguito utilizzeremo la funzione di concatenazione c() per creare un vettore.\nIl file di aiuto dice che la funzione c() ‚Äúconcatena i suoi argomenti in un vettore o in un elenco‚Äù.\n\n\n?c\n\n\n\nCreiamo ora un vettore in cui gli elementi sono dei numeri\n\n\nx <- c (4, 7, 9)\nx\n\n\n[1] 4 7 9\n\noppure un vettore in cui gli elementi sono delle stringhe\n\n\nanimali <- c(\"leoni\", \"tigri\", \"orsi\", \"Aaaargh!\")\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nFunzioni\nLe ‚Äúfunzioni‚Äù R applicano diversi tipi di trasformazioni a oggetti con diverse caratteristiche type e class.\nFunzione mean()\nAd esempio, la funzione mean() calcola la media per oggetti con type = numerico e class = vector; la funzione mean() non pu√≤ essere applicata ad oggetti con type = character (ad es. ‚Äúeil√†!‚Äù).\n\n\nx\n\n\n[1] 4 7 9\n\nmean(x)\n\n\n[1] 6.666667\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nmean(animali)\n\n\n[1] NA\n\nFunzione length()\nLa funzione `length() ritorna il numero di elementi di un vettore.\n\n\nx\n\n\n[1] 4 7 9\n\nlength(x)\n\n\n[1] 3\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nlength(animali)\n\n\n[1] 4\n\nUn singolo numero (o una singola stringa / carattere) √® un vettore con length==1\n\n\nz <- 5\nlength(z)\n\n\n[1] 1\n\nlength(\"Maria\")\n\n\n[1] 1\n\nData type di un vettore\nIl ‚Äútype‚Äù di un vettore descrive la classe a cui appartengono gli elementi del vettore. Si possono definire sei diversi ‚Äútypes‚Äù di elementi dei vettori, ma qui ne considereremo solo tre:\nnumeric:\n‚Äúinteger‚Äù (e.g., 5)\n‚Äúdouble‚Äù (e.g., 5.5)\n\ncharacter (e.g., ‚Äúozan‚Äù)\nlogical (e.g., TRUE, FALSE)\nLa funzione typeof() viene usata per esaminare il ‚Äútype‚Äù di un vettore:\n\n\nx\n\n\n[1] 4 7 9\n\ntypeof(x)\n\n\n[1] \"double\"\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\ntypeof(animali)\n\n\n[1] \"character\"\n\nData type character\nA differenza dei tipi di dati ‚Äúnumeric‚Äù utilizzati per memorizzare i numeri, il tipo di dati ‚Äúcharacter‚Äù viene utilizzato per memorizzare stringhe di testo.\nLe stringhe possono contenere qualsiasi combinazione di numeri, lettere, simboli, ecc.\nI vettori di tipo ‚Äúcharacter‚Äù sono a volte indicati come vettori di tipo alfanumerico.\nQuando si crea un vettore in cui gli elementi hanno type == character (o quando si fa riferimento al valore di una stringa), si pongano le virgolette singole o doppie attorno al testo.\nIl testo tra virgolette √® chiamato stringa.\n\n\nc1 <- c(\"cane\", 'felicit√†', 'cioccolata', 'tranquillit√†')\nc1\n\n\n[1] \"cane\"         \"felicit√†\"     \"cioccolata\"   \"tranquillit√†\"\n\ntypeof(c1)\n\n\n[1] \"character\"\n\nlength(c1)\n\n\n[1] 4\n\nI valori numerici possono anche essere memorizzati come stringhe\n\n\nc2 <- c(\"1\", \"2\", \"3\")\nc2\n\n\n[1] \"1\" \"2\" \"3\"\n\ntypeof(c2)\n\n\n[1] \"character\"\n\nIn tale caso per√≤ non possiamo applicare ad essi alcuna operazione aritmetica:\n\n\nmean(c2)\n\n\n[1] NA\n\nData type logical\nI vettori logici possono assumere tre possibili valori: TRUE, FALSE, NA.\nTRUE, FALSE, NA sono delle parole chiave; hanno un significato diverso dalle stringhe \"TRUE\", \"FALSE\", \"NA\"\nLa parola chiave NA viene utilizzata per codificare i dati mancanti.\n\n\ntypeof(TRUE)\n\n\n[1] \"logical\"\n\ntypeof(\"TRUE\")\n\n\n[1] \"character\"\n\ntypeof(c(TRUE,FALSE,NA))\n\n\n[1] \"logical\"\n\ntypeof(c(TRUE,FALSE,NA,\"FALSE\"))\n\n\n[1] \"character\"\n\nlog <- c(TRUE,TRUE,FALSE,NA,FALSE)\ntypeof(log)\n\n\n[1] \"logical\"\n\nlength(log)\n\n\n[1] 5\n\nI vettori sono omogenei\nTutti gli elementi di un vettore devono appartenere allo stesso tipo di dati.\nSe un vettore contiene elementi di diverso tipo, il vettore sar√† della classe type dell‚Äôelemento pi√π ‚Äúcomplesso‚Äù,\nI tipi di vettori atomici, dal pi√π semplice al pi√π complesso, seguono la seguente gerarchia:\nlogical < integer < double < character\n\n\ntypeof(c(TRUE, TRUE, NA))\n\n\n[1] \"logical\"\n\ntypeof(c(TRUE, TRUE, NA, 1L)) \n\n\n[1] \"integer\"\n\ntypeof(c(TRUE, TRUE, NA, 1.5))\n\n\n[1] \"double\"\n\ntypeof(c(TRUE, TRUE, NA, 1.5, \"come va?\"))\n\n\n[1] \"character\"\n\nSequenze\nDefinizione: una sequenza √® un insieme di numeri in ordine ascendente o discendente\nUn vettore contenente una ‚Äúsequenza‚Äù di numeri (ad es. 1, 2, 3) pu√≤ essere creato usando l‚Äôoperatore : con la notazione start : end\n\n\n-5:5\n\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n5:-5\n\n\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\ns <- 1:10 \ns\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nlength(s)\n\n\n[1] 10\n\nSu possono creare sequenze usando la funzione seq():\n\n\nseq(from = 1, to = 1, by = 1)\n\n\n[1] 1\n\n\n\nseq(10, 15)\n\n\n[1] 10 11 12 13 14 15\n\nseq(from = 10, to = 15, by = 1)\n\n\n[1] 10 11 12 13 14 15\n\nseq(from = 100, to = 150, by = 10)\n\n\n[1] 100 110 120 130 140 150\n\nAritmetica vettorializzata\nLe operazioni aritmetiche sui vettori vengono applicate ``elemento per elemento‚Äô‚Äô.\nQuesto √® un punto estremamente importante a cui √® necessario prestare particolare attenzione.\nAd esempio, se un singolo valore viene sommato ad un vettore, tale valore verr√† sommato a ciascun elemento del vettore:\n\n\n1:3\n\n\n[1] 1 2 3\n\n1:3 + 0.5\n\n\n[1] 1.5 2.5 3.5\n\n(1:3) * 2\n\n\n[1] 2 4 6\n\nAnche le operazioni aritmetiche che coinvolgono due vettori della stessa lunghezza vengono applicate ``elemento per elemento‚Äô‚Äô.\nPer la somma di due vettori, ad esempio, R esegue quanto segue: somma il primo elemento del vettore 1 al primo elemento del vettore 2; somma il secondo elemento del vettore 1 al secondo elemento del vettore 2; ecc.\nLo stesso vale per le altre operazioni algebriche sui vettori.\n\n\nc(1, 1, 1) + c(1, 0, -2)\n\n\n[1]  2  1 -1\n\nc(1, 1, 1) * c(1, 0, -2)\n\n\n[1]  1  0 -2\n\nDati di tipo data.frame\nLa matrice dei dati pu√≤ essere codificata in R usando quella struttura di dati che va sotto il nome di data.frame.\nLa maggior parte delle volte i data.frame vengono importati da fonti esterne. Tuttavia, √® anche possibile crearli direttamente in R. A questo fine usiamo la funzione data.frame():\n\n\ndf <- data.frame(\n  col_a = c(1, 2, 3, 4),\n  col_b = c(5, 6, 7, 8),\n  col_c = c(9, 10, 11, 12)\n)\n\n\n\nStampiamo il contenuto di df sulla console:\n\n\ndf\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\n\n\n## check\nis.data.frame(df)\n\n\n[1] TRUE\n\n\n\nhead(df) # stampa le prime 6 righe\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\nI data.frame possiedono vari attributi:\n\n\nnames(df)\n\n\n[1] \"col_a\" \"col_b\" \"col_c\"\n\ndim(df) \n\n\n[1] 4 3\n\nstr(df)\n\n\n'data.frame':   4 obs. of  3 variables:\n $ col_a: num  1 2 3 4\n $ col_b: num  5 6 7 8\n $ col_c: num  9 10 11 12\n\nLe colonne di un data.frame sono le variabili;\nLe variabili sono vettori.\nCiascuna riga del data.frame corrisponde ad un‚Äôosservazione (per esempio, un soggetto).\nEstraiamo da df la variabile col_a:\n\n\ndf$col_a\n\n\n[1] 1 2 3 4\n\nEsaminiamo la variabile col_a con pi√π attenzione:\n\n\nlength(df$col_a) # length=numbero di righe/osservazioni\n\n\n[1] 4\n\nstr(df$col_a)\n\n\n num [1:4] 1 2 3 4\n\nChe cosa c‚Äô√® da capire su vettori e data.frame?\nStruttura di base\nVettori: sono oggetti di type logical, integer, double, character.\ngli elementi di un vettore devono tutti appartere alla stessa classe type.\n\ndata.frame: sono collezioni di oggetti.\nGli elementi di un data.frame possono avere classi diverse tra loro (es., vettori numerici e vettori i cui elementi sono alfanumerici).\n\nBuona pratica: eseguire semplici diagnostiche su qualsiasi nuovo oggetto:\nlength() : quanti elementi ci sono in nell‚Äôoggetto?\ntypeof() : a che type di dati appatiene l‚Äôoggetto?\nstr() : mostra la struttura gerarchica dell‚Äôoggetto.\n\nSelezione di elementi\nR dispone di un sistema di notazione che consente di estrarre singoli elementi dagli oggetti. Per estrarre un valore da un data.frame, per esempio, dobbiamo scrivere il nome del data.frame seguito da una coppia di parentesi quadre:\n\ndf[ , ]\n\nAll‚Äôinterno delle parentesi quadre ci sono due indici separati da una virgola. R usa il primo indice per selezionare un sottoinsieme di righe del data.frame e il secondo indice per selezionare un sottoinsieme di colonne. Ad esempio:\n\n\ndf\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\ndf[1, 1]\n\n\n[1] 1\n\ndf[, 1]\n\n\n[1] 1 2 3 4\n\ndf[2, ]\n\n\n  col_a col_b col_c\n2     2     6    10\n\ndf[1:2, 3]\n\n\n[1]  9 10\n\nPer estrarre un‚Äôintera colonna, √® anche possibile usare l‚Äôoperatore $ mediante la sintassi descritta in precedenza. Possiamo anche estrarre pi√π di una colonna alla volta:\n\n\ndf[, c(\"col_b\", \"col_c\")]\n\n\n  col_b col_c\n1     5     9\n2     6    10\n3     7    11\n4     8    12\n\nEsercizi\n1. Siano x <- c(1,2,3) e y <- c(6,5,4). Si predica quello che produrr√† R quando le seguenti istruzioni vengono eseguite. Si verifichino le predizioni implementando le istruzioni seguenti in R.\nx * 2\nx * y\nx[1] * y[2]\n2. Siano x <- c(1,2,3) e y <- c(6,5,4). Qual √® il valore di x dopo avere eseguito ciascuna delle seguenti istruzioni? Si assuma che ciascuna istruzione venga eseguita dopo che x e y sono stati inizializzati come indicato sopra.\nx + x\nx <- x + x\ny <- x + x\nx <- x + 1\n3. Si determini il valore assunto dal vettore vec dopo avere eseguito le istruzioni seguenti:\nvec <- 1:10\nvec <- 1:10 * 2\nvec <- 1:10^2\nvec <- 1:10 + 1\nvec <- 1:(10 * 2)\n4. Si usi R per calcolare la somma dei quadrati dei numeri da 1 a 100: \\(1^2 + 2^2 + \\dotsb + 99^2 + 100^2\\).\n5. Sia x il vettore ottenuto utilizzando l‚Äôistruzione x <- seq(10, 30, 2).\nDi quanti elementi √® composto il vetore x?\nChe cos‚Äô√® x[2]?\nChe cos‚Äô√® x[1:5]?\nChe cos‚Äô√® x[1:3*2]?\nChe cos‚Äô√® x > 25?\nChe cos‚Äô√® x[x > 25]?\nChe cos‚Äô√® x[-1]?\nChe cos‚Äô√® x[-1:-3]?\n6. Si consideri il data.frame airquality (fornito da R).\nQuante variabili e quante osservazioni ci sono?\nQual √® il nome delle variabili?\nQual √® la classe (type) di ciascuna variabile?\n√à sensato codificare ciascuna variabile del data.frame nel formato riportato di default? Quale potrebbe essere un‚Äôalternativa migliore?\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.21 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T08:31:12+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-2/",
    "title": "Introduzione a R (2)",
    "description": "Il secondo post sulla sintassi di base di R.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nFunzioni\nR offre la possibilit√† di utilizzare molteplici funzioni che permettono di svolgere svariate operazioni, pi√π o meno complicate.\nSintassi di base\nPer esempio lancio di un dado puoÃÄ essere simulato da R con la funzione sample(). La funzione sample() prende due argomenti, il nome di un vettore e un numero chiamato size.\nLa funzione sample() ritorna un numero di elementi del vettore pari a size:\n\n\n# definiamo i valori che possono essere ottenuti dal lancio di un dado\ndie <- 1:6\ndie\n\n\n[1] 1 2 3 4 5 6\n\n# simuliamo il lancio di due dadi (o di due lanci di un dado)\nsample(die, 2)\n\n\n[1] 2 3\n\nCome si fa a sapere quanti e quali argomenti sono richiesti da una funzione? Tale informazione viene fornita dalla funzione args(). Per esempio,\n\n\nargs(sample)\n\n\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n\nci informa che il primo argomento della funzione sample() eÃÄ un vettore chiamato x, il secondo argomento √® chiamato size ed ha il significato descritto sopra, il terzo argomento, replace, specifica se il campionamento eÃÄ eseguito con o senza reimmissione, e il quarto argomento, prob, assegna delle probabilitaÃÄ agli elementi del vettore.\nSi noti che gli argomenti sono contenuti all‚Äôinterno di parentesi tonde.\nIl significato degli argomenti viene spiegato nel file di help della funzione. Si noti che agli ultimi due argomenti sono stati assegnati dei valori, detti di default. CioÃÄ significa che, se l‚Äôutilizzatore non li cambia, verranno usati da R. replace = FALSE significa che il campionamento viene eseguito senza reimmissione. Se desideriamo un campionamento con reimmissione, basta specificare replace = TRUE (nel caso di una singola estrazione eÃÄ ovviamente irrilevante). Ad esempio, l‚Äôistruzione seguente simula i risultati di 10 lanci indipendenti di un dado:\n\n\nsample(die, 10, replace = TRUE)\n\n\n [1] 4 3 1 6 4 2 5 5 5 5\n\nLo stesso risultato puoÃÄ essere ottenuto in lanci diversi. Infine, prob = NULL specifica che non viene alterata la probabilitaÃÄ di estrazione degli elementi del vettore. Manipolando questo argomento √® possibile simulare i risultati di un dado ``truccato‚Äô‚Äô, ovvero nel quale i numeri hanno probabilitaÃÄ diversa di essere osservati.\nIn generale, gli argomenti di una funzione, possono essere oggetti come vettori, matrici, altre funzioni, parametri o operatori logici.\nScrivere proprie funzioni\nAbbiamo visto in precedenza come sia possibile simulare il risultati prodotti dai lanci di due dadi. Possiamo replicare questo processo digitando ripetutamente le stesse istruzioni nella console. Otterremo ogni volta risultati diversi percheÃÅ, ad ogni ripetizione, il generatore di numeri pseudo-casuali di R dipende dal valore ottenuto dal clock interno della macchina. Tuttavia, questa procedura eÃÄ praticamente difficile da perseguire se il numero di ripetizioni eÃÄ alto. In tal caso eÃÄ vantaggioso scrivere una funzione contenente il codice che specifica il numero di ripetizioni. In questo modo, per trovare il risultato cercato basteraÃÄ chiamare la funzione una sola volta.\nLe funzioni di R sono costituite da tre elementi: il nome, il blocco del codice e una serie di argomenti. Per creare una funzione eÃÄ necessario immagazzinare in R questi tre elementi e function() consente di ottenere tale risultato usando la sintassi seguente:\n\n\nnome_funzione <- function(arg1, arg2, ...) {\n  espressione1\n  espressione2\n  return(risultato)\n}\n\n\n\nLa formattazione del codice mediante l‚Äôuso di spazi e rientri non eÃÄ necessaria ma eÃÄ altamente raccomandata per minimizzare la probabilitaÃÄ di compiere errori.\nUna chiamata di funzione eÃÄ poi eseguita nel seguente modo:\n\n\nnome_funzione(arg1, arg2, ...)\n\n\n\nPer potere essere utilizzata, una funzione deve essere presente nella memoria di lavoro di R. Le funzioni salvate in un file possono essere richiamate utilizzando la funzione source(), ad esempio,\n\n\nsource(\"file_funzioni.R\")\n\n\n\nConsideriamo ora la funzione che ritorna la somma dei punti prodotti dal lancio di due dadi onesti:\n\n\nroll <- function () {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE) \n  return(sum(dice))\n}\n\n\n\nLa funzione roll() crea il vettore die che contiene sei elementi: i numeri da 1 a 6. La funzione sample() con l‚Äôargomento replace = TRUE e l‚Äôargomento size = 2 trova i numeri usciti dal lancio di due dadi. Tramite l‚Äôoperatore di attribuzione questi due numeri sono immagazzinati nel vettore dice. La funzione sum() somma i gli elementi del vettore dice. Infine, la funzione return() (opzionale) ritorna il risultato trovato.\nInvocando la funzione roll() si ottiene dunque un punteggio che eÃÄ uguale alla somma dei valori dei due dadi lanciati. In generale, si trova un risultato diverso ogni volta che la funzione viene usata. La funzione set.seed() ci permette di replicare esattamente i risultati della generazione di numeri casuali. Per ottenere questo risultato, basta assegnare al seed un numero arbitrario:\n\n\nset.seed(12345)\nroll()\n\n\n[1] 9\n\nPacchetti\nLe funzioni di R sono organizzate in pacchetti, i piuÃÄ importanti dei quali sono giaÃÄ disponibili quando si accede al programma.\nIstallazione e upgrade dei pacchetti\nAlcuni pacchetti non sono presenti nella release di base di R. Per installare un pacchetto non presente eÃÄ sufficiente scrivere nella console:\n\n\ninstall.packages(\"nome_pacchetto\") \n\n\n\nAd esempio,\n\n\ninstall.packages(\"ggplot2\") \n\n\n\nLa prima volta che si usa questa funzione durante una sessione di lavoro si dovraÃÄ anche selezionare da una lista il sito mirror da cui scaricare il pacchetto. Il R Core Development Team lavora continuamente per migliorare le prestazioni di R, per correggere errori e per consentire l‚Äôuso di R con nuove tecnologie. Di conseguenza, periodicamente vengono rilasciate nuove versioni di R. Informazioni a questo proposito sono fornite sulla pagina web https://www.r-project.org/. Per installare una nuova versione di R si segue la stessa procedura che si eÃÄ seguita per installare la versione corrente. Anche gli autori dei pacchetti periodicamente rilasciano nuove versioni dei loro pacchetti che contengono miglioramenti di varia natura. Per eseguire l‚Äôupgrade dei pacchetti ggplot2 e dplyr, ad esempio, si usa la seguente istruzione:\n\n\nupdate.packages(c(\"ggplot2\", \"dplyr\"))\n\n\n\nPer eseguire l‚Äôupgrade di tutti i pacchetti l‚Äôistruzione eÃÄ\n\n\nupdate.packages()\n\n\n\nCaricare un pacchetto in R\nL‚Äôistallazione dei pacchetti non rende immediatamente disponibili le funzioni in essi contenute. L‚Äôistallazione di un pacchetto semplicemente copia il codice sul disco rigido della macchina in uso. Per potere usare le funzioni contenute in un pacchetto installato eÃÄ necessario caricare il pacchetto in R. CioÃÄ si ottiene con il comando:\n\n\nlibrary(\"ggplot2\")\n\n\n\nse si vuole caricare il pacchetto ggplot2. A questo punto diventa possibile usare le funzioni contenute in ggplot2.\nPer sapere quali sono i pacchetti giaÃÄ presenti nella release di R con cui si sta lavorando, basta digitare:\n\n\nsessionInfo()\n\n\nR version 3.6.3 (2020-02-29)\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\nRunning under: macOS Mojave 10.14.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nloaded via a namespace (and not attached):\n [1] fansi_0.4.2          digest_0.6.27        R6_2.5.0            \n [4] jsonlite_1.7.2       magrittr_2.0.1       evaluate_0.14       \n [7] stringi_1.5.3        rlang_0.4.10         jquerylib_0.1.3     \n[10] bslib_0.2.4          vctrs_0.3.6          rmarkdown_2.7.3     \n[13] distill_1.2          tools_3.6.3          stringr_1.4.0       \n[16] xfun_0.21            yaml_2.2.1           compiler_3.6.3      \n[19] htmltools_0.5.1.9000 knitr_1.31           downlit_0.2.1       \n[22] sass_0.3.1          \n\nGiocare a poker con R\nPer fare un esempio che ci consenta di applicare le nozioni discusse in precedenza ad una situazione concreta, consideriamo il gioco del poker.\nDefiniamo un data.frame che codifica le carte di un mazzo di 52 carte:\n\n\ndeck <- data.frame(\n  face = c(\n  \"king\", \"queen\", \"jack\", \"ten\", \" nine\", \"eight\",\"seven\", \"six\", \n  \"five\", \"four\", \"three\", \"two \", \"ace\", \"king\", \"queen\", \"jack\", \n  \"ten\", \"nine\", \"eight\", \" seven\", \"six\", \"five\", \"four\", \"three\", \n  \"two\", \"ace\", \"king\" , \"queen\", \"jack\", \"ten\", \"nine\", \"eight\", \n  \"seven\", \"six\", \" five\", \"four\", \"three\", \"two\", \"ace\", \"king\", \n  \"queen\", \"jack \", \"ten\", \"nine\", \"eight\", \"seven\", \"six\", \"five\", \n  \"four\", \" three\", \"two\", \"ace\"\n  ), \n  suit = c(\n    \"spades\", \"spades\", \"spades\" , \"spades\", \"spades\", \"spades\", \n    \"spades\", \"spades\", \"spades\" , \"spades\", \"spades\", \"spades\", \n    \"spades\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\",\n    \"clubs\", \"clubs\", \"clubs \", \"clubs\", \"clubs\", \"clubs\", \"clubs\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"diamonds\", \"diamonds\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"diamonds\", \"diamonds\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"hearts\", \"hearts\", \n    \"hearts\", \"hearts\", \" hearts\", \"hearts\", \"hearts\", \"hearts\", \n    \"hearts\", \"hearts\", \" hearts\", \"hearts\", \"hearts\"\n  ), \n  value = c(\n    13, 12, 11, 10, 9, 8 , 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, \n    9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, \n    3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n  )\n)\n\n\n\nCos√¨ facendo abbiamo ottenuto il seguente risultato:\n\n\ndeck\n\n\n     face      suit value\n1    king    spades    13\n2   queen    spades    12\n3    jack    spades    11\n4     ten    spades    10\n5    nine    spades     9\n6   eight    spades     8\n7   seven    spades     7\n8     six    spades     6\n9    five    spades     5\n10   four    spades     4\n11  three    spades     3\n12   two     spades     2\n13    ace    spades     1\n14   king     clubs    13\n15  queen     clubs    12\n16   jack     clubs    11\n17    ten     clubs    10\n18   nine     clubs     9\n19  eight     clubs     8\n20  seven     clubs     7\n21    six     clubs     6\n22   five    clubs      5\n23   four     clubs     4\n24  three     clubs     3\n25    two     clubs     2\n26    ace     clubs     1\n27   king  diamonds    13\n28  queen diamonds     12\n29   jack  diamonds    11\n30    ten  diamonds    10\n31   nine  diamonds     9\n32  eight  diamonds     8\n33  seven diamonds      7\n34    six  diamonds     6\n35   five  diamonds     5\n36   four  diamonds     4\n37  three  diamonds     3\n38    two diamonds      2\n39    ace  diamonds     1\n40   king    hearts    13\n41  queen    hearts    12\n42  jack     hearts    11\n43    ten    hearts    10\n44   nine    hearts     9\n45  eight    hearts     8\n46  seven    hearts     7\n47    six    hearts     6\n48   five    hearts     5\n49   four    hearts     4\n50  three    hearts     3\n51    two    hearts     2\n52    ace    hearts     1\n\nPoniamoci il problema di mescolare il mazzo di carte e di estrarre a caso alcune carte dal mazzo.\nL‚Äôistruzione\n\n\ndeck[1:52, ]\n\n\n     face      suit value\n1    king    spades    13\n2   queen    spades    12\n3    jack    spades    11\n4     ten    spades    10\n5    nine    spades     9\n6   eight    spades     8\n7   seven    spades     7\n8     six    spades     6\n9    five    spades     5\n10   four    spades     4\n11  three    spades     3\n12   two     spades     2\n13    ace    spades     1\n14   king     clubs    13\n15  queen     clubs    12\n16   jack     clubs    11\n17    ten     clubs    10\n18   nine     clubs     9\n19  eight     clubs     8\n20  seven     clubs     7\n21    six     clubs     6\n22   five    clubs      5\n23   four     clubs     4\n24  three     clubs     3\n25    two     clubs     2\n26    ace     clubs     1\n27   king  diamonds    13\n28  queen diamonds     12\n29   jack  diamonds    11\n30    ten  diamonds    10\n31   nine  diamonds     9\n32  eight  diamonds     8\n33  seven diamonds      7\n34    six  diamonds     6\n35   five  diamonds     5\n36   four  diamonds     4\n37  three  diamonds     3\n38    two diamonds      2\n39    ace  diamonds     1\n40   king    hearts    13\n41  queen    hearts    12\n42  jack     hearts    11\n43    ten    hearts    10\n44   nine    hearts     9\n45  eight    hearts     8\n46  seven    hearts     7\n47    six    hearts     6\n48   five    hearts     5\n49   four    hearts     4\n50  three    hearts     3\n51    two    hearts     2\n52    ace    hearts     1\n\nritorna tutte le righe e tutte e le colonne del data.frame deck. Le righe sono identificate dal primo indice che, nel caso presente, va da 1 a 52.\nPermutare in modo casuale l‚Äôindice delle righe equivale a mescolare il mazzo di carte. Per fare questo, utilizziamo la funzione sample() ponendo replace=FALSE e size uguale alla dimensione del vettore che contiene gli indici da 1 a 52:\n\n\nrandom <-\n  sample(\n    1:52,\n    size = 52, \n    replace = FALSE\n  )\nrandom\n\n\n [1] 16 26 28 24 29 11 32 49  2 22 47 38 39 30 10 17 46 40  1 12 20  8\n[23] 51 33  3  9 14 13 36 41 52 43 44 27  4 31 42  6 19  5 50 34 21 25\n[45] 45 37 48 15 23 35 18  7\n\nUtilizzando ora il vettore random di indici permutati otteniamo il risultato cercato:\n\n\ndeck_shuffled <- deck[random, ] \nhead(deck_shuffled)\n\n\n    face      suit value\n16  jack     clubs    11\n26   ace     clubs     1\n28 queen diamonds     12\n24 three     clubs     3\n29  jack  diamonds    11\n11 three    spades     3\n\nPossiamo ora scrivere una funzione che include le istruzioni precedenti:\n\n\nshuffle <- function(cards) {\n  random <- sample(1:52, size = 52, replace = FALSE)\n  return(cards[random, ])\n}\n\n\n\nInvocando la funzione shuffle() possiamo dunque generare un data.frame che rappresenta un mazzo di carte mescolato:\n\n\ndeck_shuffled <- shuffle(deck)\n\n\n\nSe immaginiamo di distribuire le carte di questo mazzo a due giocatori di poker, per il primo giocatore avremo:\n\n\ndeck_shuffled[c(1, 3, 5, 7, 9), ]\n\n\n    face     suit value\n10  four   spades     4\n27  king diamonds    13\n44  nine   hearts     9\n45 eight   hearts     8\n42 jack    hearts    11\n\ne per il secondo:\n\n\ndeck_shuffled[c(2, 4, 6, 8, 10), ]\n\n\n    face     suit value\n43   ten   hearts    10\n34   six diamonds     6\n35  five diamonds     5\n22  five   clubs      5\n23  four    clubs     4\n\nEsercizi\n1. Sia x = c(2, 1, 6, 4). Si calcoli la media di x.\nSi trovi la soluzione utilizzando le semplici operazioni algebriche di somma e divisione, specificando l‚Äôordine corretto con il quale vengono eseguite le operazioni mediante le partentesi tonde.\nLa funzione mean() ritorna la media di un vettore. Si trovi la soluzione utilizzando la funzione mean().\nSi trovi la soluzione utilizzando le funzioni base di R, quando viene implementata la formula \\(\\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i\\). Per applicare questa formula, possiamo utilizzare le seguenti ulteriori funzioni R:\nlength(), la quale ritorna il numero degli elementi del vettore che viene passato come argomento alla funzione;\nsum(), la quale ritorna la somma degli elementi del vettore che viene passato come argomento alla funzione.\n2. Sia x = c(2, 1, 6, 4). Si scriva una funzione che calcola la media di x divisa per valore massimo di x. Si trovi il risultato cercato utilizzando la funzione cos√¨ definita. In R, le funzioni min() e max() ritornano il minimo e il massimo del vettore che viene passato come argomento.\n3. Sia x = c(2, 1, 6, 4). Si verifichi che la somma degli scarti degli elementi del vettore x dalla media \\(\\bar{x}\\) √® uguale a zero. [Suggerimento: si trovi il vettore di scargi di ciascun elemento x da \\(\\bar{x}\\). Si sommino gli elementi del vettore che contiene gli scarti dalla media.]\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.21 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T08:43:42+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-3/",
    "title": "Introduzione a R (3)",
    "description": "Il terzo post sulla sintassi di base di R: strutture di controllo.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nIn R esistono strutture di controllo specifiche per regolare il flusso di esecuzione di un programma. Le istruzioni di controllo if ‚Ä¶ else consentono di selezionare tra diversi blocchi di codice. I loop permettono di ripetere ciclicamente blocchi di istruzioni per un numero prefissato di volte o fino a che una determinata condizione logica viene soddisfatta. Questo li rende utili per la programmazione di simulazioni numeriche.\nBlocchi di istruzioni\nUn blocco di istruzioni √® formato da tutte le linee di programma che sono comprese entro una coppia di parentesi graffe, apera e chiusa. La formazione di un blocco serve principalmente per isolare un gruppo di istruzioni che costituiscono una parte ben definita di programma. La struttura generale di un blocco √® la seguente:\n\n\n{\n  istruzioni\n}\n\n\n\nEsecuzione selettiva di blocchi\n√à frequente scrivere programmi che eseguono azioni diverse in corrispondenza di condizioni diverse ‚Äì il caso pi√π ovvio √® il valore di una particolare variabile. Situazioni del genere possono ben essere gestite mediante una successione di istruzioni if ‚Ä¶ else if ‚Ä¶ else.\nIn R l‚Äôistruzione condizionale if possiede la seguente sintassi:\n\nif (espressione) \n  istruzioni da eseguire se la espressione == TRUE\n\nAd esempio\n\n\nx <- 30\nif (x > 18) \n  print(\"il voto √® sufficiente\")\n\n\n[1] \"il voto √® sufficiente\"\n\n\n\nx <- 17\nif (x > 18) \n  print(\"il voto √® sufficiente\")\n\n\n\nIn questo secondo caso, la condizione non √® soddisfatta quindi non viene stampato nulla.\nCi possono per√≤ essere molteplici condizioni da valutare. Per fare questo usiamo la sintassi if () else if () else:\n\nif (espressione1) {\n  istruzioni da eseguire se la espressione1 == TRUE\n}\nelse if (espressione2) {\n  istruzioni da eseguire se la espressione2 == TRUE\n} else {\n  istruzioni da eseguire se nessuna delle espressioni √® verificata\n}\n\nAd esempio,\n\n\ntemp_eval <- function(x) {\n  if (x > 40) {\n    \"√® troppo caldo\"\n  } else if (x > 30) {\n    \"√® molto caldo\"\n  } else if (x > 20) {\n    \"ottimo!\"\n  } else {\n    \"fa troppo freddo\"\n  }\n}\n\ntemp_eval(15)\n\n\n[1] \"fa troppo freddo\"\n\nFunzione if vettorializzata\nLa funzione if pu√≤ essere applicata ad una sola condizione TRUE o FALSE. Che fare quando abbiamo a disposizione un vettore di valori logici? Di questo si occupa la funzione ifelse. Tale funzione prende tre argomenti: il primo argomento √® una condizione da valutare; il secondo argomento √® l‚Äôoutput se la condizione √® vera; il terzo argomento specifica l‚Äôoutput se la condizione √® fals. Se ad ifelse viene passato un vettore, allora la condizione del specificata dal primo argomento viene valutata per ciascun elemento del vettore. Si avr√† in output un vettore della stessa lughezza di quello in input; ogni elemento di tale vettore sar√† dato dalla scelta fatta da ifelse tra il secondo e terzo argomento, a seconda che l‚Äôespressione specificata nel primo argomento sia o meno verificata.\nPer esempio\n\n\nx <- 1:10\nifelse(x <= 5, \"valore piccolo\", \"valore grande\")\n\n\n [1] \"valore piccolo\" \"valore piccolo\" \"valore piccolo\"\n [4] \"valore piccolo\" \"valore piccolo\" \"valore grande\" \n [7] \"valore grande\"  \"valore grande\"  \"valore grande\" \n[10] \"valore grande\" \n\nIl ciclo for\nIl ciclo for eÃÄ una struttura di controllo iterativa che opera sugli elementi di un vettore. Ha la seguente struttura di base:\n\n\nfor (indice in vettore) { \n  esegui_azione \n}\n\n\n\novvero, esegui_azione viene eseguito una volta per ciascun elemento di vettore, incrementando il valore di indice dopo ciascuna iterazione.\nPer esempio, il seguente ciclo for non fa altro che stampare il valore della variabile contatore i in ciascuna esecuzione del ciclo:\n\n\nfor (i in 1:3) { \n  print(i)\n}\n\n\n[1] 1\n[1] 2\n[1] 3\n\nUn esempio (leggermente) piuÃÄ complicato eÃÄ il seguente:\n\n\nx <- seq(1, 9, by = 2) \nx\n\n\n[1] 1 3 5 7 9\n\nsum_x <- 0\nfor (i in seq_along(x)) {\n  sum_x <- sum_x + x[i]\n  cat(\"L'indice corrente e'\", i, \"\\n\")\n  cat(\"La frequenza cumulata e'\", sum_x, \"\\n\")\n}\n\n\nL'indice corrente e' 1 \nLa frequenza cumulata e' 1 \nL'indice corrente e' 2 \nLa frequenza cumulata e' 4 \nL'indice corrente e' 3 \nLa frequenza cumulata e' 9 \nL'indice corrente e' 4 \nLa frequenza cumulata e' 16 \nL'indice corrente e' 5 \nLa frequenza cumulata e' 25 \n\nUn esempio pi√π complicato √® il seguente. Chiadiamoci quanti numeri pari sono contenuti in un vettore. Per rispondere a questa domanda scriviamo la funzione count_even_numbers():\n\n\ncount_even_numbers <- function(x) {\n  count <- 0\n  for (i in seq_along(x)) {\n    if (x[i] %% 2 == 0) \n      count <- count + 1\n  }\n  count\n}\n\n\n\nNella funzione count_even_numbers() abbiamo inizializzato la variabile count a zero. Prima dell‚Äôesecuzione del ciclo for, dunque, count vale zero. Il ciclo for viene eseguito tante volte quanti sono gli elementi che costituiscono il vettore x. L‚Äôindice i dunque assume valori compresi tra 1 e il valore che corrisponde al numero di elementi di x. Infatti\n\n\nx\n\n\n[1] 1 3 5 7 9\n\nseq_along(x)\n\n\n[1] 1 2 3 4 5\n\nL‚Äôoperazione modulo, indicato con %% daÃÄ come risultato il resto della divisione euclidea del primo numero per il secondo. Intuitivamente, la divisione euclidea √® quell‚Äôoperazione che si fa quando si suddivide un numero a di oggetti in gruppi di b oggetti ciascuno e si conta quanti gruppi sono stati formati e quanti oggetti sono rimasti. Per esempio, 9 %% 2 daÃÄ come risultato 1 percheÃÅ questo eÃÄ il resto della divisione [9/2] = 4, quindi 9 - (2 * 4) = 1 e dunque il resto √® 1. L‚Äôoperazione modulo daÃÄ come risultato 0 per tutti i numeri pari.\nIn ciascuna esecuzione del ciclo for l‚Äôoperazione modulo viene eseguita, successivamente, su uno degli elementi di x. Se l‚Äôoperazione modulo daÃÄ 0 come risultato, ovvero se il valore considerato eÃÄ un numero pari, allora la variabile count viene incrementata di un‚ÄôunitaÃÄ.\nL‚Äôultima istruzione prima della parentesi graffa chiusa riporta ci√≤ che viene ritornato dalla funzione.\nPer esempio:\n\n\ncount_even_numbers(x)\n\n\n[1] 0\n\n\n\ncount_even_numbers(c(x, 24))\n\n\n[1] 1\n\n\n\ncount_even_numbers(c(2, 4, 6, 8))\n\n\n[1] 4\n\nSimulazione del gioco d‚Äôazzardo Sopra-Sotto 7\nNel gioco d‚Äôazzardo con due dadi Sopra-Sotto 7 (Under-Over 7) vengono accettati tre tipi di scommesse:\nuna scommessa alla pari che il totale saraÃÄ inferiore a 7;\nuna scommessa alla pari che il totale saraÃÄ superiore a 7;\nuna scommessa che il totale saraÃÄ proprio 7, pagata 4 a 1.\nPoniamoci il problema di valutare se eÃÄ conveniente la scommessa che il totale saraÃÄ 7 (vedremo in seguito come sia possibile risolvere questo problema in maniera formale, senza eseguire una simulazione). Iniziamo con il definire il vettore die che contiene ciascuno dei risultati possibili del lancio di un dado:\n\n\ndie <- c(1, 2, 3, 4, 5, 6) \ndie\n\n\n[1] 1 2 3 4 5 6\n\nLa funzione expand.grid() elenca tutte le possibili combinazioni degli elementi di ùëõ vettori. Con essa possiamo dunque creare tutte le possibili combinazioni possibili con due dadi: dato che ogni dado ha sei facce, le combinazioni possibili sono 6 √ó 6 = 36:\n\n\nrolls <- expand.grid(die, die) \nrolls\n\n\n   Var1 Var2\n1     1    1\n2     2    1\n3     3    1\n4     4    1\n5     5    1\n6     6    1\n7     1    2\n8     2    2\n9     3    2\n10    4    2\n11    5    2\n12    6    2\n13    1    3\n14    2    3\n15    3    3\n16    4    3\n17    5    3\n18    6    3\n19    1    4\n20    2    4\n21    3    4\n22    4    4\n23    5    4\n24    6    4\n25    1    5\n26    2    5\n27    3    5\n28    4    5\n29    5    5\n30    6    5\n31    1    6\n32    2    6\n33    3    6\n34    4    6\n35    5    6\n36    6    6\n\nLa funzione expand.grid() puoÃÄ anche essere usata con piuÃÄ di due vettori; per esempio, potremmo usarla per elencare tutte le possibili combinazioni possibili con tre dadi, quattro dadi, ecc.\nCalcoliamo ora la somma dei due lanci. Per fare questo sommiamo due vettori, dato che la somma di vettori viene eseguita in R elemento per elemento:\n\n\nrolls$value <- rolls$Var1 + rolls$Var2 \nhead(rolls, n = 3)\n\n\n  Var1 Var2 value\n1    1    1     2\n2    2    1     3\n3    3    1     4\n\nLa somma eÃÄ contenuta nella colonna value del data.frame rolls. Passiamo ora il data.frame rolls alla funzione roll_dice(). Questa fun- zione sceglie una riga a caso del data.frame e valuta il valore della variabile value. Se value (la somma dei due lanci) eÃÄ uguale a 7, la funzione ritorna una vincita di 4; altrimenti ritorna una vincita di 0.\n\n\nroll_dice <- function(df) {\n  random <- sample(1:nrow(df), size = 1)\n  if (df[random, 3] == 7) {\n    return(4)\n  } else {\n    return(0)\n  }\n}\n\n\n\nSi noti che il valore del data.frame all‚Äôintero della funzione roll_dice √® df, mentre, quando invochiamo la funzione usiamo come argomento di roll_dice l‚Äôoggetto rolls. Questo succede perch√©, quando eseguiamo l‚Äôistruzione roll_dice(rolls), comunichiamo ad R che vogliamo che venga eseguita la funzione roll_dice() e che passiamo alla funzione l‚Äôoggetto rolls. L‚Äôoggetto rolls √® l‚Äôargomento che passiamo alla funzione roll_dice(). La funzione √® stata definita in modo tale che il suo argomento, localmente, si chiama df. All‚Äôinterno della funzione, dunque, le operazioni sull‚Äôargomento che √® stato passato alla funzione verranno eseguite sull‚Äôoggetto df.\nQuesto significha, in generale, che gli oggetti che vengono manipolati all‚Äôinterno di una funzione hanno un‚Äôesistenza locale, ovvero, non esistono al di fuori della funzione. Si dice: What Happens in Vegas, stays in Vegas. Lo stesso vale per le funzioni: qualsiasi cosa succeda dentro ad una funzione, fuori non si vede.\nUsiamo ora un ciclo for per ripetere 100,000 volte una scommessa unitaria.\n\n\nn_bets <- 1e5\noutcome <- rep(NA, n_bets)\nfor (i in 1:n_bets) {\n  outcome[i] <- roll_dice(rolls)\n}\n\n\n\nLo scalare n_bets specifica il numero di ripetizioni del ciclo for. L‚Äôistruzione\n\n\noutcome <- rep(NA, n_bets)\n\n\n\ncrea un vettore vuoto, chiamato outcome, dove verranno salvati i risultati calcolati ad ogni esecuzione del ciclo. Si noti l‚Äôutilizzo delle parentesi quadre. L‚Äôistruzione [i] significa che facciamo riferimento all‚Äôelemento i-esimo di outcome. La prima volta che si entra nel ciclo, il contatore √¨ vale 1. Dunque, la vincita della prima scommessa saraÃÄ salvata nel primo elemento del vettore outcome. Eseguite tutte le istruzioni contenute nel blocco del ciclo, il contatore assume il valore 2 e le istruzioni contenute nel corpo del ciclo vengono eseguite una seconda volta.\nLa funzione roll_dice() ritorneraÃÄ la vincita (in generale, diversa da quella precedente) per una seconda scommessa e questo risultato verraÃÄ salvato nel secondo elemento del vettore outcome. Questo processo viene ripetuto n_bets volte. Il fatto che la variabile contatore assuma il valore finale previsto (nel nostro caso n_bets = 100000) eÃÄ la condizione che fa terminare il ciclo.\nUna volta completata l‚Äôesecuzione del ciclo, il vettore outcome conterraÃÄ le medie di 100000 scommesse. La media di questi 100,000 numeri eÃÄ quello che ci possiamo aspettare di guadagnare, o di perdere, per ogni scommessa unitaria. Se tale valore eÃÄ uguale a 1, questo vuol dire che, a lungo andare, ci aspettiamo neÃÅ di vincere neÃÅ di perdere, ma di ricevere una somma uguale alla posta versata. Se tale valore eÃÄ minore di 1 ci aspettiamo a lungo andare di perdere una proporzione della posta versata pari a 1 meno il valore trovato dalla simulazione. Se tale valore eÃÄ maggiore di 1 ci aspettiamo a lungo andare di vincere una proporzione della posta versata pari al valore trovato dalla simulazione meno 1. Nel caso presente, il risultato della simulazione eÃÄ 0.669 (contro un risultato teorico di 0.667). Ci√≤ significa che, puntando 100 euro, a lungo andare ci aspettiamo di perdere 33.1 euro.\nEsercizi\n1. Utilizzando un ciclo for, si stampi il valore del contatore del ciclo, quando il ciclo for viene eseguito 10 volte. Si usi la funzione print() per stampare il risultato desiderato in ciscuna iterazione.\n2. Sia x = c(3, 1, 7, 9). Utilizzando un ciclo for, si crei un nuovo vettore y i cui elementi hanno un valore doppio rispetto a x.\n3. Si usi un ciclo for per stampare, ad ogni iterazione, il numero 1 un numero di volte uguale al contatore del ciclo. Per esempio, la terza volta che il ciclo viene eseguito va stampata la sequenza 1 1 1.\n\n\n\n4. Si carichi il data.frame iris fornito da R. Si trovi il numero di elementi distinti in ciascuna colonna del data.frame. Per trovare la soluzione si utilizzi un ciclo for. La soluzione √® riportata qui sotto.\n[Suggerimento. I data.frame forniti da R si leggono nel workspace mediante la funzione data(). Per risolvere il problema dobbiamo prima definire un vettore vuoto dove salveremo i risultati. Poi dobbiamo trovare il modo per fare riferimento a ciascuna colonna del data.frame all‚Äôinterno del ciclo for. Un modo per fare questo √® di fare riferimento a ciascuna colonna i-esima del data.frame df con la sintassi df[[i]]. Infine, dobbiamo trovare un modo per contare il numero di elementi distinti di un vettore. La funzione unique() fa proprio questo.\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n          35           23           43           22            3 \n\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.21 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T12:09:48+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-4/",
    "title": "Introduzione a R (4)",
    "description": "Il quarto post sulla sintassi di base di R: input/output.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nLeggere i dati\nCaricare i dati in R √® una delle cose pi√π importanti che si devono fare. Se non puoi importare i dati in R, allora non importa quali trucchetti potresti avere imparato: nulla pu√≤ essere fatto. Importare i dati √® anche una delle cose pi√π frustranti - non solo in R, ma in generale. Se sei fortunato, i dati che stai cercando di caricare in R sono stati salvati come file .csv. L‚Äôestensione .csv sta per ‚ÄúValori separati da virgola‚Äù e significa che i dati sono memorizzati in righe con virgole che separano le variabili. In questo caso, √® facile importare i dati in R.\nOra, anche se sei fortunato e i tuoi dati sono in formato .csv, se sei un novizio del computer, allora avrai ancora qualche frustrazione nell‚Äôimportare il file in R. Infatti, √® necessario comunicare ad R dove sul computer √® stato salvato il file da importare.\n√à possibile risolvere tale problema specificando il percorso completo o il percorso relativo al file che si desidera caricare. In generale, √® sempre meglio utilizzare un percorso relativo, in maniera tale che, se si copia la cartella di un progetto da un computer all‚Äôaltro, tutto continua a funzionare.\n√à una buona pratica impostare una determinata struttura di file con dati memorizzati in una cartella separata per ciascun progetto. Vediamo come si possa fare questo.\nCreare un progetto con RStudio\nCome indicato nell‚Äôesercizio 1 qui sotto, creiamo una cartella chiamata psicometria, dove salveremo tutti gli scritp Rmd che creeremo in questo corso. Una volta creata questa cartella, apriamo RStudio e creiamo un nuovo progetto. Per creare un progetto, da RStudio utilizziamo il percorso File/New Project... Quello che facciamo in questo modo √® di comunicare ad R che questo specifico progetto √® situato nella cartella di lavoro psicometria. L‚Äôindirizzo di questa cartella pu√≤ essere ottenuto con l‚Äôistruzione getwd().\nPossiamo creare altre cartelle, dentro psicometria. Per esempio, creiamo da cartella data, dove salveremo i file di dati. Per fare un esercizio, utilizzeremo il file di dati wais.csv che pu√≤ essere scaricato da Moodle. I dati in questo file corrispondono ai punteggi di quattro sottoscale della WAIS-IV completate da 90 studenti del corso di Psicometria dell‚ÄôAA 2015/2016. Per fare un confronto, sappiamo che, nella popolazione, i punteggi di ciascuna sottoscala si distribuiscono normalmente con media 10 e deviazione standard 3.\nSalviamo questo file nella cartella data e poniamoci il problema di importare tali dati in R.\nImportare i dati in formato .csv\nPer leggere i dati contenuti in un file esterno, dobbiamo usare una funzione R capace di leggere i dati in quel formato e dobbiamo specificare dove si trova il file di dati che vogliamo importare. I dati sono conenuti del file wais.csv; dunque il file √® in formato .csv. Per leggere i dati user√≤ la funzione read_csv() e, per usare tale funzione, prima devo caricare il boundle di pacchetti tidyverse.\nDove si trova il file dei dati?\nOra si pone il problema di specificare dove si trova il file sul computer. √à facile risolvere questo problema se abbiamo definito con R un progetto che identifica la cartella di lavoro che ci interessa.\nAvendo gi√† creato il progetto psicometria, per specificare dove si trova il file che vogliamo importare possiamo utilizzare la funzione here::here(). Ovvero, rispetto alla cartella di lavoro che abbiamo definito, basta specificare in maniera relativa la cartella in cui abbiamo inserito il file. La sintassi da usare √® la seguente:\n\n\nlibrary(\"here\")\nhere(\"data\", \"wais.csv\")\n\n\n[1] \"/Users/corrado/OneDrive - unifi.it/blog/data/wais.csv\"\n\nIn questo modo viene precisato l‚Äôindirizzo del file che voglio importare.\nPer importare i dati usiamo l‚Äôindirizzo specificato come indicato sopra:\n\n\nlibrary(\"tidyverse\")\ndf <- read_csv(here(\"data\", \"wais.csv\"))\n\n\n\nEsaminare i dati con glimpse()\nPossiamo esaminare il contenuto di df nel modo seguente:\n\n\nglimpse(df)\n\n\nRows: 90\nColumns: 7\n$ personal_code <chr> \"160996FMT784\", \"310795FMV569\", \"131096FSL143\"‚Ä¶\n$ MC            <dbl> 11, 9, 7, 5, 3, 7, 4, 8, 6, 13, 11, 9, 9, 9, 1‚Ä¶\n$ RA            <dbl> 11, 6, 11, 8, 9, 11, 7, 10, 3, 11, 9, 12, 9, 1‚Ä¶\n$ RS            <dbl> 12, 12, 12, 8, 9, 11, 12, 10, 14, 14, 11, 14, ‚Ä¶\n$ CR            <dbl> 16, 14, 11, 10, 11, 13, 11, 14, 12, 17, 14, 12‚Ä¶\n$ wrkn_mem      <dbl> 22, 15, 18, 13, 12, 18, 11, 18, 9, 24, 20, 21,‚Ä¶\n$ pr_speed      <dbl> 28, 26, 23, 18, 20, 24, 23, 24, 26, 31, 25, 26‚Ä¶\n\nL‚Äôoutput di glimpse() ci comunica che ci sono 90 osservazioni e 7 variabili. I primi valori di ciascuna variabile vengono stampati. La funzione glimpse() ci dice anche quale classe di dati appartengono le variabili. Per esempio, personal_code appartiene alla classe char. Ci√≤ vuol dire che le modalit√† di tale variabile sono delle stringhe alfanumeriche. Le altre varibili sono di type dbl, il che vuol dire che sono dei numeri reali.\nPossiamo anche esaminare i dati con la funzione head()\n\n\nhead(df)\n\n\n# A tibble: 6 x 7\n  personal_code    MC    RA    RS    CR wrkn_mem pr_speed\n  <chr>         <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 160996FMT784     11    11    12    16       22       28\n2 310795FMV569      9     6    12    14       15       26\n3 131096FSL143      7    11    12    11       18       23\n4 230195FER172      5     8     8    10       13       18\n5 190396FCP941      3     9     9    11       12       20\n6 170896FMO879      7    11    11    13       18       24\n\noppure con summary()\n\n\nsummary(df)\n\n\n personal_code            MC               RA              RS       \n Length:90          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n                    NA's   :8        NA's   :8       NA's   :8      \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n NA's   :8       NA's   :8       NA's   :8      \n\nFormati diversi\nI dati possono essere in vari formati (Excel, SPSS, SAS, solo testo, RDS, ‚Ä¶). Il pacchetto rio si pone l‚Äôobiettivo di semplificare il processo di importazione dei dati in R e l‚Äôesportazione dei dati da R. Dopo avere installato il pacchetto, install.packages(\"rio\"), lo carichiamo:\n\n\nlibrary(\"rio\")\n\n\n\nPer garantire che rio sia completamente funzionante, la prima volta che si usa rio eseguiamo la seguente istruzione:\n\n\ninstall_formats()\n\n\n\nA questo punto, importare i dati √® molto semplice\n\n\ndf1 <- rio::import(here(\"data\", \"wais.csv\"))\n\n# confirm identical\nall.equal(df, df1, check.attributes = FALSE)\n\n\n[1] TRUE\n\nLeggiamo un file di dati in formato Excel:\n\n\ndf2 <- rio::import(here(\"data\", \"Jordan_etal.xls\"))\nglimpse(df2)\n\n\nRows: 747\nColumns: 50\n$ goodinfo           <dbl> 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,‚Ä¶\n$ condemn            <dbl> 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0,‚Ä¶\n$ qAnswered          <dbl> 16, 16, 16, 16, 16, 16, 4, 16, 16, 4, 16,‚Ä¶\n$ totalCorrect       <dbl> 16, 16, 16, 16, 16, 16, 3, 16, 16, 2, 16,‚Ä¶\n$ percCorrect        <dbl> 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.75,‚Ä¶\n$ ansall             <dbl> 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0,‚Ä¶\n$ dowork             <dbl> 4, 5, 2, 4, 3, 6, NA, 2, 2, NA, 1, NA, 4,‚Ä¶\n$ doromantic         <dbl> 2, 4, 1, 5, 5, 3, NA, 2, 2, NA, 1, NA, 4,‚Ä¶\n$ doacademic         <dbl> 2, 4, 5, 4, 3, 2, 3, 3, 2, NA, 2, NA, 4, ‚Ä¶\n$ dodrugs            <dbl> 2, 5, 3, 3, 2, 3, NA, 3, 2, 4, 1, 4, 5, N‚Ä¶\n$ trustswork         <dbl> 5, 4, 5, 4, 5, 3, NA, 6, 6, NA, 7, NA, 5,‚Ä¶\n$ trustsromantic     <dbl> 3, 4, 6, 5, 4, 4, NA, 5, 5, NA, 7, NA, 5,‚Ä¶\n$ trustsacademic     <dbl> 5, 1, 5, 4, 5, 5, 5, 3, 5, NA, 5, NA, 6, ‚Ä¶\n$ trustsdrugs        <dbl> 5, 5, 5, 4, 5, 5, NA, 5, 5, 3, 7, 4, 5, N‚Ä¶\n$ trustgwork         <dbl> 4, 4, 5, 4, 5, 2, NA, 5, 5, NA, 7, NA, 6,‚Ä¶\n$ trustgromantic     <dbl> 4, 5, 5, 4, 5, 2, NA, 5, 5, NA, 6, NA, 5,‚Ä¶\n$ trustgacademic     <dbl> 5, 3, 3, 4, 5, 5, 5, 3, 5, NA, 6, NA, 5, ‚Ä¶\n$ trustgdrugs        <dbl> 5, 4, 3, 4, 5, 5, NA, 5, 5, 3, 5, 4, 4, N‚Ä¶\n$ likework           <dbl> 5, 4, 6, 4, 4, 3, NA, 5, 5, NA, 6, NA, 5,‚Ä¶\n$ likeromantic       <dbl> 3, 4, 7, 3, 5, 4, NA, 5, 5, NA, 7, NA, 5,‚Ä¶\n$ likeacademic       <dbl> 5, 4, 6, 4, 5, 6, 5, 4, 5, NA, 3, NA, 6, ‚Ä¶\n$ likedrugs          <dbl> 5, 4, 4, 4, 4, 6, NA, 4, 5, 3, 6, 4, 4, N‚Ä¶\n$ compq1work         <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, NA, 2, NA, 2,‚Ä¶\n$ compq1romantic     <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, NA, 2, NA, 2,‚Ä¶\n$ compq1academic     <dbl> 2, 1, 2, 1, 1, 1, 2, 2, 1, NA, 2, NA, 2, ‚Ä¶\n$ compq1drugs        <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, 3, 2, 1, 2, N‚Ä¶\n$ compq2work         <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, NA, 1, NA, 1,‚Ä¶\n$ compq2romantic     <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, NA, 1, NA, 1,‚Ä¶\n$ compq2academic     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, 1, NA, 1, ‚Ä¶\n$ compq2drugs        <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, 2, 1, 1, 1, N‚Ä¶\n$ compq3work         <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, NA, 3, NA, 3,‚Ä¶\n$ compq3romantic     <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, NA, 3, NA, 3,‚Ä¶\n$ compq3academic     <dbl> 3, 3, 3, 3, 3, 3, 1, 3, 3, NA, 3, NA, 3, ‚Ä¶\n$ compq3drugs        <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, 3, 3, 1, 3, N‚Ä¶\n$ compq4work         <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, NA, 1, NA, 1,‚Ä¶\n$ compq4romantic     <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, NA, 1, NA, 1,‚Ä¶\n$ compq4academic     <dbl> 1, 2, 1, 1, 2, 2, 2, 2, 1, NA, 1, NA, 1, ‚Ä¶\n$ compq4drugs        <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, 1, 1, 2, 1, N‚Ä¶\n$ sumdo              <dbl> 5.50, 3.50, 5.25, 4.00, 4.75, 4.50, 5.00,‚Ä¶\n$ sumtrusts          <dbl> 4.50, 3.50, 5.25, 4.25, 4.75, 4.25, 5.00,‚Ä¶\n$ sumtrustg          <dbl> 4.50, 4.00, 4.00, 4.00, 5.00, 3.50, 5.00,‚Ä¶\n$ sumlike            <dbl> 4.50, 4.00, 5.75, 3.75, 4.50, 4.75, 5.00,‚Ä¶\n$ sumtotal           <dbl> 4.7500, 3.7500, 5.0625, 4.0000, 4.7500, 4‚Ä¶\n$ age                <dbl> 47, NA, 35, 38, 24, NA, NA, 29, 34, NA, 2‚Ä¶\n$ gender             <dbl> 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1,‚Ä¶\n$ edu                <dbl> 6, NA, 5, 4, 5, NA, NA, 6, 4, NA, 6, NA, ‚Ä¶\n$ income             <dbl> 1, NA, 7, 7, 3, NA, NA, 4, 5, NA, 7, NA, ‚Ä¶\n$ generaltrust       <dbl> 5, NA, 6, 1, 5, NA, NA, 6, 5, NA, 5, NA, ‚Ä¶\n$ reason             <chr> \"Tried to balance or qualify the facts an‚Ä¶\n$ previousexperience <dbl> 3, NA, 2, 3, 2, NA, NA, 4, 3, NA, 1, NA, ‚Ä¶\n\nEsportare i dati\n√à possibile salvare i dati che abbiamo manipolato in R in un file esterno.\n\n\nrio::export(df2, \"jordan.csv\")\nrio::export(df2, \"jordan.rds\")\n\n\n\nSe adesso guardiamo nella cartella di lavoro dove stiamo lavorando, vedremo che sono stati creati i file jordan.csv e jordan.rds.\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] rio_0.5.26 forcats_0.5.1 stringr_1.4.0 dplyr_1.0.5\n[5] purrr_0.3.4 readr_1.4.0 tidyr_1.1.3 tibble_3.1.0\n[9] ggplot2_3.3.3 tidyverse_1.3.0 here_1.0.1\nloaded via a namespace (and not attached): [1] Rcpp_1.0.6 lubridate_1.7.10 assertthat_0.2.1\n[4] rprojroot_2.0.2 digest_0.6.27 utf8_1.1.4\n[7] R6_2.5.0 cellranger_1.1.0 backports_1.2.1\n[10] reprex_1.0.0 evaluate_0.14 httr_1.4.2\n[13] pillar_1.5.1 rlang_0.4.10 curl_4.3\n[16] readxl_1.3.1 rstudioapi_0.13 data.table_1.14.0\n[19] jquerylib_0.1.3 rmarkdown_2.7.3 foreign_0.8-75\n[22] munsell_0.5.0 broom_0.7.5 compiler_3.6.3\n[25] modelr_0.1.8 xfun_0.21 pkgconfig_2.0.3\n[28] htmltools_0.5.1.9000 downlit_0.2.1 tidyselect_1.1.0\n[31] fansi_0.4.2 crayon_1.4.1 dbplyr_2.1.0\n[34] withr_2.4.1 grid_3.6.3 jsonlite_1.7.2\n[37] gtable_0.3.0 lifecycle_1.0.0 DBI_1.1.1\n[40] magrittr_2.0.1 scales_1.1.1 zip_2.1.1\n[43] cli_2.3.1 stringi_1.5.3 debugme_1.1.0\n[46] fs_1.5.0 xml2_1.3.2 bslib_0.2.4\n[49] ellipsis_0.3.1 generics_0.1.0 vctrs_0.3.6\n[52] openxlsx_4.2.3 distill_1.2 tools_3.6.3\n[55] glue_1.4.2 hms_1.0.0 yaml_2.2.1\n[58] colorspace_2.0-0 rvest_1.0.0 knitr_1.31\n[61] haven_2.3.1 sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-10T22:05:39+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-5/",
    "title": "Introduzione a R (5)",
    "description": "Il quinto post sulla sintassi di base di R: `tidyverse`.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nManipolazione dei dati\nSi chiamano ‚Äúdati grezzi‚Äù quelli che provengono dal mondo circostanze, i dati raccolti per mezzo degli strumenti usati negli esperimenti, per mezzo di interviste, di questionari, ecc. Questi dati raramente vengono forniti con una struttura logica precisa. Per poterli elaborare mediante dei software dobbiamo prima trasformarli in maniera tale che abbiano una struttura logica organizzata. La struttura che solitamente si utilizza eÃÄ quella tabellare (matrice dei dati), ovvero si dispongono i dati in una tabella nella quale a ciascuna riga corrisponde ad un‚Äôosservazione e ciascuna colonna corrisponde ad una variabile rilevata. In R una tale struttura eÃÄ chiamata* data fram*e.\nIl pacchetto dplyr, che √® al momento uno dei pacchetti pi√π utilizzati per la gestione dei dati, offre una serie di funzionalit√† che consentono di ottenere il risultato descritto in precedenza e consente inoltre di eseguire le operazioni piuÃÄ comuni di manipolazione dei dati in maniera piuÃÄ semplice rispetto a quanto succeda quando usiamo le funzioni base di R.\ndplyr si fonda su cinque funzioni base:\nfilter(),\nselect(),\nmutate(),\narrange(),\nsummarise().\nA questi cinque comandi di base si aggiungono\nil pipe %>% che serve a concatenare pi√π operazioni,\ngroup_by che viene utilizzato per il subsetting.\nIn particolare, considerando una matrice osservazioni per variabili (colonne), select() e mutate() si occupano di organizzare le variabili, filter() e arrange() i casi (righe), e summarise() i gruppi.\nPer introdurre le funzionalitaÃÄ di base di dplyr, usiamo i dati contenuti nel file sheffield.csv che puoÃÄ essere scaricato da Moodle. Carichiamo i pacchetti tidyverse e here:\n\n\nlibrary(\"tidyverse\")\nlibrary(\"here\")\n\n\n\nCreiamo l‚Äôoggetto df_sheffield leggendo da il file .csv nella working directory:\n\n\nlibrary(here)\ndf_sheffield <- read_csv(here(\"data\", \"sheffield.csv\"))\n\n\n\nCon l‚Äôistruzione here(\"data\", \"sheffield.csv\") ho specificato che, rispetto alla cartella di lavoro di default del progetto, il file si trova nella cartella data.\nI dati sono stati raccolti in una ricerca che ho eseguito un po‚Äô di tempo fa sul problema della menzogna (Caudek, Lorenzino, & Liperoti, 2017). La teoria del carico cognitivo della menzogna ipotizza che mentire richieda un maggior carico cognitivo che dire la veritaÃÄ. In linea con questa ipotesi eÃÄ stato dimostrato che le risposte menzognere sono tipicamente associate ad un innalzamento delle latenze di risposta rispetto alle risposte veritiere. Lo Sheffild Lie Test eÃÄ una procedura comuterizzata che richiede ai soggetti di rispondere ad una serie di domande presentate sullo schermo in un ordine randomizzato. In metaÃÄ delle prove ai soggetti viene chiesto di dire la veritaÃÄ e nell‚Äôaltra metaÃÄ di mentire. Il risultato tipico eÃÄ che i tempi di reazione tendono ad essere maggiori quando ai soggetti viene chiesto di mentire piuttosto che di dire la veritaÃÄ.\nI dati contenuti nel file sheffield.csv riportano i tempi di reazione medi di 75 soggetti. Nel file sono contenute le seguenti variabili: lie indica se la consegna era di mentire o di dire la veritaÃÄ, self distingue le domande riferite al soggetto dalle domande riferite ad un estraneo, sex riporta il genere, age riporta l‚ÄôetaÃÄ dei soggetti, pr_speed riporta i punteggi della scala WAIS relativa alla velocitaÃÄ di elaborazione, wrkn_mem riporta i punteggi della scala WAIS relativa alla memoria di lavoro, mrt riporta la media dei tempi di reazione.\nFiltrare le righe del data.frame con filter()\nLa funzione filter() consente di selezionare un sottoinsieme di osservazioni in un dataset. Per esempio, possiamo selezionare tutte le osservazioni nella variabile lie contrassegnate come yes e tutte le osservazioni nella variabile self contrassegnate come no:\n\n\ndf_sheffield %>% \n  dplyr::filter(lie == \"yes\", self == \"no\")\n\n\n# A tibble: 75 x 8\n      id lie   self  sex     age pr_speed wrkn_mem   mrt\n   <dbl> <chr> <chr> <chr> <dbl>    <dbl>    <dbl> <dbl>\n 1     1 yes   no    F        19       26       15 1454.\n 2     2 yes   no    F        20       23       18 1984.\n 3     3 yes   no    M        20       24       18 2760.\n 4     4 yes   no    F        19       23       11 1848.\n 5     5 yes   no    F        19       24       18 1810.\n 6     6 yes   no    F        19       26        9 2036.\n 7     7 yes   no    F        19       31       24 2292.\n 8     8 yes   no    F        20       25       20 1558.\n 9     9 yes   no    M        20       26       21 1589.\n10    10 yes   no    F        19       23       18 2136.\n# ‚Ä¶ with 65 more rows\n\nSelezionare le colonne del data.frame con select()\nLa funzione select() consente di selezionare un sottoinsieme di variabili in un dataset. Per esempio, possiamo selezionare solo le variabili id e mrt:\n\n\ndf_sheffield %>% \n  dplyr::select(id, mrt)\n\n\n# A tibble: 300 x 2\n      id   mrt\n   <dbl> <dbl>\n 1     1 1340.\n 2     1 1064.\n 3     1 1454.\n 4     1 1112.\n 5     2 1918.\n 6     2 1527.\n 7     2 1984.\n 8     2 1665.\n 9     3 2492.\n10     3 2186.\n# ‚Ä¶ with 290 more rows\n\nAggiungere una colonna al data.frame con mutate()\nTalvolta vogliamo creare una nuova variabile in uno stesso dataset ad esempio sommando o dividendo due variabili, oppure calcolandone la media. A questo scopo si usa la funzione mutate(). Per esempio, la somma dei punteggi di velocitaÃÄ di elaborazione pr_speed e di memoria di lavoro wrkn_mem della WAIS si trova come:\n\n\ndf <- df_sheffield %>%\n  mutate(\n    wais_sub = pr_speed + wrkn_mem\n  ) %>%\n  select(pr_speed, wrkn_mem, wais_sub)\nhead(df)\n\n\n# A tibble: 6 x 3\n  pr_speed wrkn_mem wais_sub\n     <dbl>    <dbl>    <dbl>\n1       26       15       41\n2       26       15       41\n3       26       15       41\n4       26       15       41\n5       23       18       41\n6       23       18       41\n\nOrdinare i dati con arrange()\nLa funzione arrange() serve a ordinare i dati in base ai valori di una o piuÃÄ variabili. Per esempio, possiamo ordinare la variabile mrt dal valore piuÃÄ alto al piuÃÄ basso in questo modo:\n\n\ndf_sheffield %>% \n  arrange(desc(mrt))\n\n\n# A tibble: 300 x 8\n      id lie   self  sex     age pr_speed wrkn_mem   mrt\n   <dbl> <chr> <chr> <chr> <dbl>    <dbl>    <dbl> <dbl>\n 1     3 yes   no    M        20       24       18 2760.\n 2     3 no    no    M        20       24       18 2492.\n 3     3 yes   yes   M        20       24       18 2389.\n 4    17 yes   no    F        23       21       15 2333.\n 5     7 yes   no    F        19       31       24 2292.\n 6    29 yes   no    F        19       22       18 2187.\n 7     3 no    yes   M        20       24       18 2186.\n 8    25 yes   no    F        19       28       19 2141.\n 9    10 yes   no    F        19       23       18 2136.\n10    73 yes   no    F        20       24       17 2082.\n# ‚Ä¶ with 290 more rows\n\nRaggruppare i dati con group_by()\nLa funzione group_by() serve a raggruppare insieme i valori in base a una o piuÃÄ variabili. La vedremo in uso in seguito insieme a summarise().\nSommario dei dati con summarise()\nLa funzione summarise() collassa il dataset in una singola riga dove viene riportato il risultato della statistica richiesta. Per esempio, la media dei tempi di reazione eÃÄ\n\n\ndf_sheffield %>% \n  summarise(\n    y = mean(mrt, na.rm = TRUE) \n  )\n\n\n# A tibble: 1 x 1\n      y\n  <dbl>\n1 1443.\n\nCalcoliamo ora la media dei tempi di reazione in funzione delle variabili self e lie, ma solo per le femmine:\n\n\ndf_sheffield %>% \n  dplyr::filter(sex == \"F\") %>% \n  group_by(self, lie) %>% \n  summarise(\n    y = mean(mrt, na.rm = TRUE) \n  )\n\n\n# A tibble: 4 x 3\n# Groups:   self [2]\n  self  lie       y\n  <chr> <chr> <dbl>\n1 no    no    1445.\n2 no    yes   1694.\n3 yes   no    1197.\n4 yes   yes   1414.\n\nEsercizi\n1. Utilizziamo nuovamente i dati sulla menzogna discussi in precedenza.\nSi crei sul proprio computer una cartella chiamata psicometria.\nSi apra RStudio e si crei un nuovo progetto che ha psicometria come cartella di lavoro.\nNella cartella psicometria si creino delle altre cartelle. Una sar√† chiamata data e in essa verranno salvati i file contenti i dati che utilizzeremo in questo corso. Altre cartelle avranno, ciascuna, il nome dell‚Äôargomento considerato. Ad esempio, se l‚Äôargomento trattato √® probabilit√† potremmo creare una cartella con questo nome. Tuttavia, vi incoraggio a non usare mai caratteri speciali nel nome dei file e delle cartelle. Invece dello spazio potete usare il trattino basso. Gli accenti vanno eliminati. √à pi√π semplice (ed elegante) scrivere in inglese, cos√¨ il problema non si pone. Quindi la cartella pu√≤ essere chiamata probability. Considerate che R √® sensibile alle maiuscole: probability e Probability non sono a stessa cosa!\nSi salvi il file sheffield.csv nella cartella data.\nUtilizzando la funzione here() del pacchetto here si specifichi dov‚Äô√® il file sheffield.csv e si leggano i dati in R.\nSi generi un istogramma della variabile mrt che riporta la media dei tempi di reazione per ciascun soggetto in ciascuna condizione.\n2. Utilizzando gli stessi dati, si determini\nse in questo campione le femmine, in media, hanno valori pi√π alti o pi√π bassi dei maschi sulla variabile che codifica la velocit√† di elaborazione nella WAIS (pr_speed);\nse in questo campione le femmine, in media, hanno valori pi√π alti o pi√π bassi dei maschi sulla variabile che codifica la memoria di lavoro nella WAIS (wrkn_mem).\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] here_1.0.1 forcats_0.5.1 stringr_1.4.0 dplyr_1.0.4\n[5] purrr_0.3.4 readr_1.4.0 tidyr_1.1.2 tibble_3.1.0\n[9] ggplot2_3.3.3 tidyverse_1.3.0\nloaded via a namespace (and not attached): [1] tidyselect_1.1.0 xfun_0.21 bslib_0.2.4\n[4] haven_2.3.1 colorspace_2.0-0 vctrs_0.3.6\n[7] generics_0.1.0 htmltools_0.5.1.9000 yaml_2.2.1\n[10] utf8_1.1.4 rlang_0.4.10 jquerylib_0.1.3\n[13] pillar_1.5.1 withr_2.4.1 glue_1.4.2\n[16] DBI_1.1.1 dbplyr_2.1.0 modelr_0.1.8\n[19] readxl_1.3.1 lifecycle_1.0.0 munsell_0.5.0\n[22] gtable_0.3.0 cellranger_1.1.0 rvest_0.3.6\n[25] evaluate_0.14 knitr_1.31 fansi_0.4.2\n[28] broom_0.7.5 Rcpp_1.0.6 backports_1.2.1\n[31] scales_1.1.1 debugme_1.1.0 jsonlite_1.7.2\n[34] fs_1.5.0 distill_1.2 hms_1.0.0\n[37] digest_0.6.27 stringi_1.5.3 rprojroot_2.0.2\n[40] grid_3.6.3 cli_2.3.1 tools_3.6.3\n[43] magrittr_2.0.1 sass_0.3.1 crayon_1.4.1\n[46] pkgconfig_2.0.3 downlit_0.2.1 ellipsis_0.3.1\n[49] xml2_1.3.2 reprex_1.0.0 lubridate_1.7.9.2\n[52] rstudioapi_0.13 assertthat_0.2.1 rmarkdown_2.7.3\n[55] httr_1.4.2 R6_2.5.0 compiler_3.6.3\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T12:21:33+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-6/",
    "title": "Introduzione a R (6)",
    "description": "Il sesto post sulla sintassi di base di R: `ggplot()`.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nCreare grafici con ggplot2\nLa visualizzazione si pone l‚Äôobiettivo di rappresentare i dati tramite linee, forme, colori e cos√¨ via. Esiste una relazione strutturata, una mappatura, tra le variabili nei dati e la loro rappresentazione nel grafico visualizzato sullo schermo o sulla pagina. La funzione ggplot() fornisce una serie di strumenti per mappare i dati sugli elementi visivi del grafico, per specificare il tipo di grafico che si desidera ottenere e per controllare in modo preciso i dettagli di come le informazioni verranno visualizzate. Un ottimo approfondimento delle tematiche della visualizzazione si pu√≤ trovare in Data visualizazion: a practical introduction di Kieran Healy.\nIl pacchetto ggplot2 fornisce un‚Äôimplementazione della cosiddetta grammatica della grafica (grammar of graphics) di Wilkinson. Tale grammatica consiste in uno schema generale da applicare alla visualizzazione dei dati e permette di organizzare un grafico attraverso la combinazione di componenti semantiche distinte, come oggetti geometrici, scale e coordinate. Per questa ragione, in ggplot2 un grafico eÃÄ costituito da una serie di strati (layers).\nNella visualizzazione √® necessario specificare le connessioni tra le variabili nei dati e i colori, i punti e le forme che vengono rappresentate sullo schermo. In ggplot(), queste connessioni logiche tra i dati e gli elementi del grafico sono chiamate mappature estetiche, o semplicemente estetiche, e vengono specificate dalla funzione aes().\nLa funzione da cui si parte per inizializzare un grafico √® ggplot(). Tale funzione richiede due argomenti: il primo √® il data frame che contiene i dati da visualizzare; il secondo √® la funzione aes() che specifica come le variabili nei dati si associano logicamente alle mappature estetiche del grafico.\nLa funzione aes() richiede di specificare x e y, ovvero i nomi delle colonne del data frame che rappresentano le variabili da porre rispettivamente sugli assi orizzontale e verticale.\n√à poi necessario specificare il tipo di grafico che vogliamo costruire (ad esempio un grafico a dispersione, un grafico a scatola o un grafico a barre), aggiungendo all‚Äôoggetto creato da ggplot() tutte le componenti necessarie. In ggplot() la tipologia del grafico da costruire √® chiamata geom(). Funzioni del tipo geom_...() vengono quindi usate per aggiungere al livello di base barre, linee, punti, e cosiÃÄ via. Nello specifico, la tipologia del grafico viene specificata dalle seguenti funzioni:\ngeom_bar(): crea un grafico a barre;\ngeom_point(): crea un diagramma a dispersione;\ngeom_line(): crea un layer con una linea retta;\ngeom_histogram(): crea un istogramma;\ngeom_boxplot(): crea un box-plot;\ngeom_errorbar(): crea un grafico a barre che rappresenta gli intervalli di confidenza.\nInfine, tramite altre funzioni, ad esempio labs(), saraÃÄ possibile definire i dettagli piuÃÄ fini.\nUna generica istruzione ha la seguente forma:\n\n\nmy_graph <- \n  ggplot(my_data, aes(x_var, y_var)) +\n  geom_...()\n\n\n\nLa prima volta che si usa il pacchetto ggplot2 eÃÄ necessario installarlo. Per fare questo possiamo installare tidyverse che, oltre a contenere ggplot2, fornisce altre utili funzioni per l‚Äôanalisi dei dati. Per attivare il pacchetto tidyverse si usa l‚Äôistruzione:\n\n\nlibrary(\"tidyverse\")\n\n\n\nOgni volta che si inizia una sessione R eÃÄ necessario attivare i pacchetti che si vogliono usare, ma non eÃÄ necessario istallarli una nuova volta.  \nDiagramma a dispersione con la funzione geom_point()\nA titolo eseplificativo utilizzeremo il dataset msleep fornito dal pacchetto ggplot2 che descrive le ore di sonno medie di 83 specie di mammiferi. Poniamoci il problema di rappresentare graficamente la relazione tra il numero medio di ore di sonno giornaliero (sleep_total) e il peso dell‚Äôanimale (bodywt) (Savage e West, 2007).\nInnanzitutto carichiamo i dati in R:\n\n\ndata(msleep)\n\n\n\nGeneriamo un diagramma a dispersione con le impostazioni di default di ggplot2:\n\n\np <- msleep %>%\n  ggplot(\n    aes(x = bodywt, y = sleep_total)\n  ) +\n  geom_point()\n\nprint(p)\n\n\n\n\nTramite la mappatura estetica geom_point() viene creato un diagramma a dispersione.\nPer visualizzare maggiori informazioni, coloriamo in maniera diversa i punti che rappresentano animali carnivori, erbivori, ecc. Tale risultato si ottiene specificando l‚Äôargomento col = nella funzione aes():\n\n\np <- msleep %>%\n  ggplot(\n    aes(\n      x = bodywt, y = sleep_total, col = vore\n    )\n  ) +\n  geom_point()\nprint(p)\n\n\n\n\nEÃÄ chiaro, anche senza fare alcuna analisi statistica, che la relazione tra le due variabili non eÃÄ lineare. Trasformando in maniera logaritmica i valori dell‚Äôasse x la relazione si linearizza.\n\n\np <- msleep %>%\n  ggplot(\n    aes(\n      x = log(bodywt), y = sleep_total, col = vore\n    )\n  ) +\n  geom_point()\nprint(p)\n\n\n\n\nCambiamo ora il tema del grafico, aggiungiamo le etichette sugli assi e il titolo. Per cambiare il tema del grafico, usiamo il cowplot con l‚Äôistruzione theme_set():\n\n\nlibrary(\"cowplot\")\ntheme_set(theme_cowplot())\n\nmsleep %>%\n  ggplot(\n    aes(x = log(bodywt), y = sleep_total, col = vore)\n  ) +\n  geom_point(size = 2) +\n  theme(legend.title = element_blank()) +\n  labs(\n    x = \"Log Peso Corporeo\",\n    y = \"Totale Ore di Sonno\",\n    title = \"Il sonno in 83 specie di mammiferi\", subtitle = \"Savage e West (2007)\"\n  )\n\n\n\n\nIstogramma con la funzione geom_histogram()\nCreiamo ora un istogramma che rappresenta la distribuzione del (logaritmo del) peso medio del cervello delle 83 specie di mammiferi considerate da Savage e West (2007).\n\n\nmsleep %>%\n  ggplot(\n    aes(log(brainwt))\n  ) +\n  geom_histogram(aes(y = ..density..)) +\n  labs(\n    x = \"Log Peso Cervello\",\n    y = \"Frequenza Relativa\"\n  ) +\n  theme(legend.title = element_blank())\n\n\n\n\nL‚Äôargomento aes(y=..density..) in geom_histogram() produce le frequenze relative. L‚Äôopzione di default (senza questo argomento) porta ggplot() a rappresentare le frequenze assolute.\nEsercizio con dati WAIS\nUtilizzando i dati contenuti nel file wais.csv, l‚Äôobiettivo √® di esaminare la distribuzine dei punteggi Ricerca di simboli, separatamente per maschi e femmine. Tali distribuzioni condizionate possono essere visualizzate con un box plot. Prima di fare questo, per√≤, √® necessario trasformare e ricodificare i dati.\nLeggere i dati\nI valori riportati corrispondono ai punteggi di quattro sottoscale della WAIS-IV completate da 72 studenti del corso di Psicometria dell‚ÄôAA 2015/2016. Nella popolazione, i punteggi di ciascuna sottoscala si distribuiscono normalmente con media 10 e deviazione standard 3.\nIniziamo a leggere i dati in R. Sul mio computer, i dati wais.csv sono contenuti della cartella data.\n\n\nlibrary(\"here\")\nlibrary(\"tidyverse\")\n\ntemp <- read_csv(here(\"data\", \"wais.csv\"))\nsummary(temp)\n\n\n personal_code            MC               RA              RS       \n Length:90          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n                    NA's   :8        NA's   :8       NA's   :8      \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n NA's   :8       NA's   :8       NA's   :8      \n\nElimino le osservazioni contenenti dati mancanti (codificati in R con NA).\n\n\ndf_wais <- temp[complete.cases(temp), ]\nsummary(df_wais)\n\n\n personal_code            MC               RA              RS       \n Length:82          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n\nPosso ora rimuovere l‚Äôoggetto temp:\n\n\nrm(temp)\n\n\n\nDefinisco la variabile ‚Äògenere‚Äô\nDefinisco la variabile sex (genere) estraendo il settimo carattere da personal_code. Per fare questo uso la funzione substr(). La variabile sex viene poi trasformata in un fattore in quanto rappresenta una variabile qualitativa. Usando la funzione summary vediamo che ci sono 73 femmine e 9 maschi.\n\n\ndf_wais$sex <- substr(df_wais$personal_code, 7, 7)\ndf_wais$sex <- factor(df_wais$sex)\nsummary(df_wais$sex)\n\n\n F  M \n73  9 \n\nStatistiche descrittive condizionate alle modalit√† di una variabile categoriale\nEsaminiamo la media e la deviazione standard della variabile RS separatamente per maschi e femmine. Per fare questo, uso l‚Äôoperatore ‚Äúpipe‚Äù %>% che prende l‚Äôoutput di una funzione e lo trasforma nell‚Äôinput della funzione successiva. Cos√¨, l‚Äôistruzione df_wais %>% significa: prendi il data frame df_wais (ovvero quello che viene prodotto quando la stringa df_wais viene digitata sullo schermo) e usalo come input per la funzione group_by. Tale funzione raggruppa i dati in funzione delle modalit√† della variabile sex, nel caso presente. Ovvero, tutte le manipolazioni che verranno effettuate sul data frame in seguito saranno fatte separatamente per le due modalit√† di sex. La pipe successiva passa questo input alla funzione summarise(), la quale consente di calcolare delle statistiche descrittive. Nel caso presente, la media mean() e la deviazione standard sd(), entrambe per la variabile RS. Nell‚Äôoutput che verr√† prodotto, le medie dei punteggi RS per maschi e femmine costituiranno gli elementi di un vettore chiamato m; le deviazioni standard dei punteggi RS per maschi e femmine costituiranno gli elementi di un vettore chiamato std.\n\n\ndf_wais %>%\n  group_by(sex) %>%\n  summarise(\n    m = mean(RS),\n    std = sd(RS)\n  )\n\n\n# A tibble: 2 x 3\n  sex       m   std\n* <fct> <dbl> <dbl>\n1 F      10.8  2.87\n2 M      11.6  2.40\n\nBox plot con la funzione geom_boxplot()\nIl box plot fornisce una rappresetazione grafica della distribuzione di una variabile. In particolare, descrive visivamente la forma della distribuzione e la tendenza centrale (mediana). Nel grafico seguente viene riportato un boxplot separato per maschi e femmine. Usiamo ggplot() con la geom_boxplot():\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(x = sex, y = RS)\n  ) +\n  geom_boxplot()\nprint(p1)\n\n\n\n\nSovrapponiamo ai due boxplot i dati grezzi.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\")\nprint(p1)\n\n\n\n\nAggiungiamo le etichette a ciascun asse.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  )\nprint(p1)\n\n\n\n\nPoniamoci ora il problema di modificare le modalit√† della variabile sex. Per fare questo uso la funzione fct_recode contenuta nel pacchetto forcats. Si noti che la modalit√† della variabile che vogliamo cambiare si trova a destra dell‚Äôuguale, tra virgolette; la nuova modalit√† si trova a sinistra del segno di uguale, anch‚Äôessa tra virgolette.\n\n\nlibrary(\"forcats\")\ndf_wais <- df_wais %>%\n  mutate(\n    sex = fct_recode(\n      sex,\n      \"Femmmine\" = \"F\",\n      \"Maschi\" = \"M\"\n    )\n  )\n\n\n\nRifaccio ora il grafico dopo avere modificato il data frame.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  ) \n\nprint(p1)\n\n\n\n\nPossiamo colorare il boxplot usando l‚Äôargomento fill = nella funzione aes():\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS, fill = sex)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  ) +\n  theme(legend.position = \"none\")\n\nprint(p1)\n\n\n\n\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] here_1.0.1 cowplot_1.1.1 forcats_0.5.1 stringr_1.4.0\n[5] dplyr_1.0.4 purrr_0.3.4 readr_1.4.0 tidyr_1.1.2\n[9] tibble_3.1.0 ggplot2_3.3.3 tidyverse_1.3.0\nloaded via a namespace (and not attached): [1] Rcpp_1.0.6 lubridate_1.7.9.2 assertthat_0.2.1\n[4] rprojroot_2.0.2 digest_0.6.27 utf8_1.1.4\n[7] R6_2.5.0 cellranger_1.1.0 backports_1.2.1\n[10] reprex_1.0.0 evaluate_0.14 httr_1.4.2\n[13] highr_0.8 pillar_1.5.1 rlang_0.4.10\n[16] readxl_1.3.1 rstudioapi_0.13 jquerylib_0.1.3\n[19] rmarkdown_2.7.3 labeling_0.4.2 munsell_0.5.0\n[22] broom_0.7.5 compiler_3.6.3 modelr_0.1.8\n[25] xfun_0.21 pkgconfig_2.0.3 htmltools_0.5.1.9000 [28] downlit_0.2.1 tidyselect_1.1.0 fansi_0.4.2\n[31] crayon_1.4.1 dbplyr_2.1.0 withr_2.4.1\n[34] grid_3.6.3 jsonlite_1.7.2 gtable_0.3.0\n[37] lifecycle_1.0.0 DBI_1.1.1 magrittr_2.0.1\n[40] scales_1.1.1 cli_2.3.1 stringi_1.5.3\n[43] debugme_1.1.0 farver_2.1.0 fs_1.5.0\n[46] xml2_1.3.2 bslib_0.2.4 ellipsis_0.3.1\n[49] generics_0.1.0 vctrs_0.3.6 distill_1.2\n[52] tools_3.6.3 glue_1.4.2 hms_1.0.0\n[55] yaml_2.2.1 colorspace_2.0-0 rvest_0.3.6\n[58] knitr_1.31 haven_2.3.1 sass_0.3.1\n\n\n\n\n",
    "preview": "posts/2021-03-08-introduzione-a-r-6/introduzione-a-r-6_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-03-08T12:27:20+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-03-08-istogramma/",
    "title": "Istogramma",
    "description": "Dati BDI-II di Zetsche, BuÃàrkners & Renneberg (2020).",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nObiettivi di questo tutorial\nIn questo tutorial ci poniamo il problema di costruire un istrogramma utilizzando la funzione ggplot() del pacchetto ggplot2 in R. Vedremo quali sono i limiti degli istogrammi. Concluderemo introducendo una rappresentazione alternativa, la densit√† della frequenza dei dati, la quale attenua i limiti degli istogrammi.\nCarichiamo i pacchetti necessari\n\n\nsuppressPackageStartupMessages(library(\"tidyverse\")) \nsuppressPackageStartupMessages(library(\"bayesplot\"))\ntheme_set(bayesplot::theme_default(base_size=14))\nsuppressPackageStartupMessages(library(\"knitr\"))\nsuppressPackageStartupMessages(library(\"kableExtra\"))\nsuppressPackageStartupMessages(library(\"patchwork\"))\nsuppressPackageStartupMessages(library(\"car\"))\ntable_nums <- captioner::captioner(prefix = \"Tavola\")\nfigure_nums <- captioner::captioner(prefix = \"Figura\")\nknitr::opts_chunk$set(fig.align = \"center\", fig.width=7, fig.height=5)\n\n\n\nIntroduzione\nIniziamo con delle considerazioni di base.\nL‚Äôintervallo (a, b] si dice aperto a sinistra e chiuso a destra. Significa\n\\[\na < x \\leq b,\n\\]\novvero, descrive la situazione nella quale i valori che coincidono con il limite superiore dell‚Äôintervallo verranno inclusi nell‚Äôintervallo, mentre i valori che coincidono con il limte inferiore dell‚Äôintervanno non verranno inclusi nell‚Äôintervallo.\nConsideriamo questi dati:\n\n\nx <- c(1, 2, 1, 1, 5, 3, 2, 6)\n\n\n\nSupponiamo di volere i seguenti intervalli aperti a sinistra e chiusi a destra:\n(0, 2]\n(2, 4]\n(4, 6]\n(6, 8]\nPer la variabile x, la distribuzione di frequenze assolute diventa:\nIntervallo\nfrequenza\n(0, 2]\n5\n(2, 4]\n1\n(4, 6]\n2\n(6, 8]\n0\nSe invece consideriamo gli intervalli chiusi a sinistra e aperti a destra, [a, b), ovvero\n\\[\na \\leq x < b,\n\\]\nallora otteniamo una diversa distribuzione di frequenze assolute:\nIntervallo\nfrequenza\n[0, 2)\n3\n[2, 4)\n3\n[4, 6)\n1\n[6, 8)\n1\nUsiamo ora R per ottenere i risultati precedenti.\nUno dei modi possibili per calcolare le frequenze assolute √® quello di usare la funzione cut(). Mediante tal funzione √® possibile dividere il campo di variazione (ovvero, la differenza tra il valore massimo di una distribuzione ed il valore minimo) di una variabile continua x in intervalli e codificare ciascun valore x nei termini dell‚Äôintervallo a cui appartiene.\nIniziamo con gli intervalli aperti a sinistra e chiusi a destra:\n\n\nx_cat <- cut(\n  x,\n  breaks = c(0, 2, 4, 6, 8),\n  right = TRUE\n)\n\n\n\nPossiamo ora usare la funzione table() la quale ritorna una tabella con le frequenze assolute di ciascuna modalit√† della variabile in input.\n\n\ntable(x_cat)\n\n\nx_cat\n(0,2] (2,4] (4,6] (6,8] \n    5     1     2     0 \n\nLa distribuzione di frequenze per intervalli chiusi a sinistra e aperti a destra √®:\n\n\nx_cat <- cut(\n  x,\n  breaks = c(0, 2, 4, 6, 8),\n  right = FALSE\n)\n\n\n\n\n\ntable(x_cat)\n\n\nx_cat\n[0,2) [2,4) [4,6) [6,8) \n    3     3     1     1 \n\nIstogramma\nCreiamo ora un istogramma usando i valori x.\nQual √® l‚Äôaltezza della barra in corrispondeza dell‚Äôintervallo (0,2]?\nLa base √® pari a 2 e l‚Äôarea √® 5/8. Dunque l‚Äôaltezza √®\n\n\n(5/8) / 2\n\n\n[1] 0.3125\n\nUsiamo ggplot()\n\n\nx %>% \n  as.data.frame() %>% \n  ggplot(aes(x = x)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 2, 4, 6, 8) \n  ) \n\n\n\n\nQuesto ci conferma che, di default, ggplot() usa intervalli chiusi a destra.\nCambiamo ora il default e specifichiamo intervalli chiusi a sinistra:\n\n\nx %>% \n  as.data.frame() %>% \n  ggplot(aes(x = x)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 2, 4, 6, 8),\n    closed = \"left\"\n  ) \n\n\n\n\nManipolazione dei dati (importazione e pulizia)\nConsidereremo ora i dati di Zetsche, BuÃàrkner, & Renneberg (2020) e ci poniamo il problema di descrivere la distribuzione dei punteggi BDI-II dei 67 partecipanti. Uno di essi non ha risposto e quindi c‚Äô√® un dato mancante.\nCreiamo la varibile bdi che contiene i valori del valore BDI-II dei 66 soggetti:\n\n\nbysubj <- data.frame(\nbdi <- c(\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,\n  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3, 3,  5,  7,  9, 12, 19,\n  22, 22, 24, 25, 25, 26, 26, 26, 27, 27, 28, 28, 30, 30, 30, 31, 31, 33,\n  33, 34, 35, 35, 35, 36, 39, 41, 43, 43, 44\n  )\n)\n\n\n\nCalcolo delle frequenze assolute\nI seguenti cut-off vengono usati per interpretare il BDI‚ÄêII:\ndepressione minima = 0 ‚Äì 13,\ndepressione lieve = 14 ‚Äì 19,\ndepressione moderata = 20 ‚Äì 28,\ndepressione severa = 29 ‚Äì 63.\nCalcoliamo le frequenze assolute per i seguenti intervalli aperti a destra: [0, 13.5), [13.5, 19.5), [19.5, 28.5), [28.5, 63). Esaminando i dati, vediamo che 36 soggetti cadono nella prima classe. Dobbiamo per√≤ eseguire quest‚Äôoperazione di conteggio utilizzando R.\n\n\nbysubj$bdi_level <- cut(\n  bysubj$bdi,\n  breaks = c(0, 13.5, 19.5, 28.5, 63),\n  include.lowest = TRUE,\n  labels = c(\n    \"minimal\", \"mild\", \"moderate\", \"severe\"\n  )\n)\n\nbysubj$bdi_level\n\n\n [1] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n [8] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[15] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[22] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[29] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[36] minimal  mild     moderate moderate moderate moderate moderate\n[43] moderate moderate moderate moderate moderate moderate moderate\n[50] severe   severe   severe   severe   severe   severe   severe  \n[57] severe   severe   severe   severe   severe   severe   severe  \n[64] severe   severe   severe  \nLevels: minimal mild moderate severe\n\n\n\ntable(bysubj$bdi_level)\n\n\n\n minimal     mild moderate   severe \n      36        1       12       17 \n\nPer ottenere le frequenze relative √® sufficiente dividere ciascuna frequenza assoluta per il numero totale di osservazioni:\n\n\ntable(bysubj$bdi_level) / sum(table(bysubj$bdi_level))\n\n\n\n   minimal       mild   moderate     severe \n0.54545455 0.01515152 0.18181818 0.25757576 \n\nIn questo modo abbiamo ottenuto le distribuzioni di frequenza assoluta e relativa.\nLimiti delle classi\nFrequenza assoluta\nFrequenza relativa\n[0, 13.5)\n36\n36/66\n[13.5, 19.5)\n1\n1/66\n[19.5, 28.5)\n12\n12/66\n[28.5, 63]\n17\n17/66\nIstogramma\nL‚Äôistogramma delle frequenze assolute disegna un rettangolo sopra ogni intervallo specificato, la cui altezza corrisponde alla frequenza assoluta della classe. Per esempio, alla classe [0, 13.5] abbiamo associato la frequenza assoluta di 36. Nell‚Äôistogramma delle frequenze assolute l‚Äôaltezza del primo rettangolo sar√† dunque uguale a 36.\nNell‚Äôistogramma delle frequenze relative viene invece rappresentata la frequenza relativa delle classi: l‚Äôarea di ogni rettangolo √® proporzionale alla frequenza relativa della classe. Come si trova l‚Äôaltezza delle barre dell‚Äôistogramma in tali circostanze? Per la classe [0, 13.5), ad esempio, la frequenza relativa √® 36/66. Tale valore corrisponde all‚Äôarea del rettangolo. Dato che la base del rettangolo √® 13.5, l‚Äôaltezza sar√† 36/66 / 13.5, ovvero {r 36/66 / 13.5}. E cos√¨ via per le altre barre dell‚Äôistogramma.\nVisualizzazione con ggplot()\n\n\n\n\n\np1 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 13.5, 19.5, 28.5, 44.1) # il valore BDI-II massimo √® 44\n  ) +\n  scale_x_continuous(breaks=c(0, 13.5, 19.5, 28.5, 44.1)) +\n  labs(\n    x = \"BDI-II\",\n    y = \"DensitaÃÄ di frequenza\"\n  )\np1\n\n\n\n\nFigure 1: Figura 1: Istogramma delle frequenze relative creato con ggplot().\n\n\n\n√à pi√π comune, per√≤, utilizzare classi di ampiezza uguale.\n\n\n\n\n\np2 <- bysubj %>%\n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = seq(0, 44.1, length.out = 7)\n  ) +\n  scale_x_continuous(breaks=c(0.00,  7.35, 14.70, 22.05, 29.40, 36.75, 44.10)) +\n  labs(\n    x = \"BDI-II\",\n    y = \"DensitaÃÄ di frequenza\",\n    caption = \"Fonte: Zetsche, Buerkner, & Renneberg (2020)\"\n  )\n\n\n\n\n\np1 + p2\n\n\n\n\nLimite dell‚Äôistogramma\nCome abbiamo notato sopra, uno dei limiti degli istogrammi √® che il profilo dell‚Äôistogramma √® arbitrario: a seconda del numero e dei limiti delle classi che vengono scelte, cambiano sia il numero che la forma delle barre dell‚Äôistogramma.\nLa densit√† della frequenza dei dati\nIl problema precedente pu√≤ essere alleviato utilizzando una rappresentazione alternativa della distribuzione di frequenza, ovvero la stima della densit√† della frequenza dei dati. Un modo semplice per pensare a tale rappresentazione, che in inglese va sotto il nome di density plot, √® quello di immaginare un grande campione di dati, in modo che diventi possibile definire un enorme numero di classi di equivalenza di ampiezza molto piccola, le quali non risultino vuote. In tali circostanze, la funzione di densit√† empirica non √® altro che il profilo `lisciato‚Äô dell‚Äôistogramma. La stessa idea si applica anche quando il campione √® pi√π piccolo. Un esempio √® fornito nella figura seguente.\n\n\n\n\n\np3 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..), \n    breaks = seq(0, 44.1, length.out = 7)\n  ) +\n  geom_density(\n    aes(x = bdi), \n    adjust = 0.5, \n    size = 0.8, \n    fill = \"steelblue3\", \n    alpha = 0.5\n  ) +\n  labs(\n    x = \"BDI-II\",\n    y = \"DensitaÃÄ di frequenza\"\n  )\np3\n\n\n\n\nFigure 2: Figura 3: Istogramma delle frequenze relative con sovrapposta la stima della densit√† della frequenza dei dati.\n\n\n\nGuardando il grafico della densit√† della frequenza dei dati possiamo notare che ci sono due valori che tendono a ricorrere pi√π spesso nella distribuzione dei punteggi del BDI-II. Il primo valore tipico √® di poco superiore allo zero. Il secondo valore tipico √® all‚Äôincirca uguale a 25. Tali valori tipici si chiamano mode. Nel caso presente √® sensato che una moda della distribuzione corrisponda ad un valore BDI-II molto basso, dato che il campione include 36 soggetti sani, e che una moda corrisponda ad un valore BDI-II di depressione moderata/severa, in quanto il campione include 30 soggetti clinicamente depressi. Ovviamente, se vogliamo rappresentare solo la densit√† della frequenza dei dati (senza l‚Äôistogramma) procediamo come indicato qui sotto.\n\n\n\n\n\np4 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_density(\n    aes(x = bdi), \n    adjust = 0.5, \n    size = 0.8, \n    fill = \"steelblue3\", \n    alpha = 0.5\n  ) +\n  labs(\n    x = \"BDI-II\",\n    y = \"DensitaÃÄ di frequenza\",\n    caption = \"Fonte: Zetsche, Buerkner, & Renneberg (2020)\"\n  )\np4\n\n\n\n\nFigure 3: Figura 4: Grafico della stima della densit√† della frequenza dei dati.\n\n\n\n\n\np3 + p4\n\n\n\n\nConclusioni\nL‚Äôarea totale di un istogramma √® pari a 1.0.\nQuando guardiamo un istogramma dobbiamo pensare che l‚Äôarea di ciascuna barra √® uguale alla frequenza relativa (ovvero alla proporzione) dei casi che cadono in quella classe.\nL‚Äôistogramma ci dice come si distribuiscono (proporzionalmente) le osservazioni di un campione nelle classi che sono state definite.\nIl fatto che l‚Äôarea totale dell‚Äôistogramma sia unitaria significa che essa √® la somma di tutte le proporzioni rappresentate dalla barre dell‚Äôistogramma.\nIl grafico della funzione di densit√† empirica attenua l‚Äôarbitrariet√† della scelta del numero e della dimensione delle classi dell‚Äôistogramma e ci fornisce una rappresentazione grafica maggiormente comprensibile.\nOriginal Computing Environment\n\n\nsessionInfo()\n\n\nR version 3.6.3 (2020-02-29)\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\nRunning under: macOS Mojave 10.14.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n [1] car_3.0-10       carData_3.0-4    patchwork_1.1.1 \n [4] kableExtra_1.3.4 knitr_1.31       bayesplot_1.8.0 \n [7] forcats_0.5.1    stringr_1.4.0    dplyr_1.0.4     \n[10] purrr_0.3.4      readr_1.4.0      tidyr_1.1.2     \n[13] tibble_3.1.0     ggplot2_3.3.3    tidyverse_1.3.0 \n\nloaded via a namespace (and not attached):\n [1] httr_1.4.2           sass_0.3.1           jsonlite_1.7.2      \n [4] viridisLite_0.3.0    modelr_0.1.8         bslib_0.2.4         \n [7] assertthat_0.2.1     highr_0.8            cellranger_1.1.0    \n[10] yaml_2.2.1           gdtools_0.2.3        pillar_1.5.1        \n[13] backports_1.2.1      glue_1.4.2           digest_0.6.27       \n[16] rvest_0.3.6          colorspace_2.0-0     captioner_2.2.3     \n[19] htmltools_0.5.1.9000 plyr_1.8.6           pkgconfig_2.0.3     \n[22] broom_0.7.5          haven_2.3.1          scales_1.1.1        \n[25] webshot_0.5.2        svglite_1.2.3.2      openxlsx_4.2.3      \n[28] distill_1.2          rio_0.5.26           downlit_0.2.1       \n[31] farver_2.1.0         generics_0.1.0       ellipsis_0.3.1      \n[34] withr_2.4.1          cli_2.3.1            magrittr_2.0.1      \n[37] crayon_1.4.1         readxl_1.3.1         evaluate_0.14       \n[40] fs_1.5.0             fansi_0.4.2          xml2_1.3.2          \n[43] foreign_0.8-75       tools_3.6.3          data.table_1.14.0   \n[46] hms_1.0.0            lifecycle_1.0.0      munsell_0.5.0       \n[49] reprex_1.0.0         zip_2.1.1            compiler_3.6.3      \n[52] jquerylib_0.1.3      systemfonts_1.0.1    rlang_0.4.10        \n[55] debugme_1.1.0        grid_3.6.3           ggridges_0.5.3      \n[58] rstudioapi_0.13      labeling_0.4.2       rmarkdown_2.7.3     \n[61] gtable_0.3.0         abind_1.4-5          DBI_1.1.1           \n[64] curl_4.3             R6_2.5.0             lubridate_1.7.9.2   \n[67] utf8_1.1.4           stringi_1.5.3        Rcpp_1.0.6          \n[70] vctrs_0.3.6          dbplyr_2.1.0         tidyselect_1.1.0    \n[73] xfun_0.21           \n\n\n\n\n",
    "preview": "posts/2021-03-08-istogramma/istogramma_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2021-03-09T14:51:45+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 960
  },
  {
    "path": "posts/2021-03-07-bibliografia/",
    "title": "Le citazioni",
    "description": "Bibliografia della prova finale e della tesi di laurea magistrale.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "tesi"
    ],
    "contents": "\nHo creato un breve video con le istruzioni per creare la bibliografia delle tesi di laurea. Ci sono tanti tutorial sul web per affrontare questo problema: le semplici considerazioni che fornisco qui sono un possibile punto di partenza.\nAl di l√† delle cose che dico qui, consiglio fortemente tutti i laureandi, triennali e magistrali, di scrivere la tesi di laurea in R Markdown, usando le indicazioni fornite in un altro post e, soprattutto, di utilizzare bibtex per la bibliografia, in modo tale essere sicuri di ottenere il risultato corretto senza doversi preoccupare di applicare le (complicate) regole APA ‚Äì i ricercatori fanno cos√¨ quando scrivono un articolo.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:30:05+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-07-istruzioniprovafinalel24/",
    "title": "Istruzioni per la prova finale L-24",
    "description": "Tutto quello che avreste sempre voluto sapere sulla stesura dell'elaborato finale e non avete mai osato chiedere.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "tesi"
    ],
    "contents": "\nMediante questo link potete accedere ad un video in cui rispondo a tutte le possibili domande che potreste avere su questo argomento. Descriver√≤ la procedura che consiglio per realizzare l‚Äôelaborato finale e per preparare la presentazione orale. Una volta scritto l‚Äôelaborato finale seguendo queste istruzioni, potete iniziare a lavorare alla presentazione orale. Sulla presentazione orale riceverete poi altri feedback negli incontri settimanali con i laureandi che saranno specificamente dedicati a questo tema.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:31:13+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-07-pagina-facebook/",
    "title": "Pagina facebook",
    "description": "Social media.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "social media"
    ],
    "contents": "\n√à attiva la pagina facebook del laboratorio. Contiene informazioni su progetti in corso e presentazioni dei laureandi. √à una creazione dei torocinanti del laboratorio.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:31:42+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-07-scrivere-la-tesi-con-r-markdown/",
    "title": "Scrivere la tesi con R Markdown",
    "description": "Video tutorial sull'uso di R Markdown per la tesi di laurea.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "R",
      "tesi"
    ],
    "contents": "\nSeguendo questo link potete trovare un video-tutorial sull‚Äôuso di R Markdown per la scrittura della tesi di laurea. Il materiale che ho predisposto pu√≤ essere scaricato selezionando questo link. Buon lavoro!\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:32:16+01:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "L'inizio",
    "description": "Benvenuti nel mio blog.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "social media"
    ],
    "contents": "\nIl blog √® scritto in R Markdown usando le funzioni del pacchetto distill. Ho seguito le istruzioni contenute in Building a blog with distill e Creating a Blog.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:36:07+01:00",
    "input_file": {}
  }
]
