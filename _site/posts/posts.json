[
  {
    "path": "posts/2021-03-20-valore-atteso-e-varianza-di-variabili-aleatorie-continue/",
    "title": "Valore atteso e varianza di variabili aleatorie continue",
    "description": "Usiamo `R` per il calcolo degli integrali.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-21",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\n\nContents\nTL; DR\nLa funzione di densità di probabilità\nLa probabilità \\(P(a \\leq Y \\leq b)\\)\nIl valore atteso\nLa varianza\n\nTL; DR\nIn questo post esamineremo il calcolo di\nprobabilità,\nvalore atteso,\nvarianza\nnel caso di variabili aleatorie continue.\nLa cattiva notizia è che la soluzione di tali problemi richiede la conoscenza del calcolo integrale. Oppure, se vogliamo evitare di avventurarci in quella direzione, possiamo trovare facilmente la soluzione utilizzando un software, come ad esempio R. Vedremo qui come si fa.\nLa funzione di densità di probabilità\nConsideriamo la variabile aleatoria continua \\(Y\\) avente una distribuzione di densità \\(f_Y(y)\\). La probabilità che \\(Y\\) assuma valori compresi tra \\(a\\) e \\(b\\), con \\(a<b\\), è\n\\[\nP(a \\leq Y \\leq b) = \\int_a^b f_Y(y) dy.\n\\]\nPer definizione, \\(P(-\\infty \\leq Y \\leq +\\infty) = 1\\) e quindi \\(\\int_{-\\infty}^{+\\infty} f_Y(y) dy = 1\\).\nSupponiamo che\n\\[\nf_X (x) = \\frac{3}{x^4}, \\quad x > 1\n\\] Verifichiamo che \\(f_X (x)\\) sia una funzione di densità. Definiamo la funzione \\(f_X (x)\\) in R nel modo seguente:\n\n\nf <- function(x) 3 / x^4\n\n\n\nMediante le seguenti istruzioni possiamo ottenere una rappresentazione grafica di \\(f_X(x)\\). Iniziamo a creare un data.frame fittizio\n\n\nlibrary(\"tidyverse\", warn.conflicts = FALSE)\np <- ggplot(data = data.frame(x = 0), mapping = aes(x = x))\n\n\n\ne utilizziamo la funzione stat_function() per creare il plot:\n\n\np + \n  stat_function(fun = f) + \n  xlim(1, 5) +\n  labs(\n    y = \"f(x)\"\n  )\n\n\n\n\nVerifichiamo che l’area sia unitaria:\n\n\nintegrate(\n  f, \n  lower = 1, \n  upper = Inf\n)$value\n\n\n[1] 1\n\nLa probabilità \\(P(a \\leq Y \\leq b)\\)\nCalcoliamo una probabilità, ovvero l’area sottesa alla funzione di densità in un intervallo. Per esempio, calcoliamo la probabilità \\(P(1.5 \\leq Y \\leq 2.5)\\).\nPer trovare l’area sottesa alla funzione di densità nell’intervallo [1.5, 2.5] utilizziamo la funzione integrate() come indicato di seguito:\n\n\nintegrate(\n  f, \n  lower = 1.5, \n  upper = 2.0\n)$value\n\n\n[1] 0.1712963\n\nIl valore atteso\nIl valore atteso di una variabile aleatoria continua \\(Y\\) avente una distribuzione di densità \\(f_Y(y)\\) è\n\\[\n\\mathbb{E}(Y) = \\mu_Y = \\int_a^b y f_Y(y) dy.\n\\] Anche in questo caso dobbiamo trovare un integrale. Nel caso dell’esempio, iniziamo con il definire la funzione \\(g\\):\n\n\ng <- function(x) x * f(x)\n\n\n\nIl valore atteso è dato da:\n\n\nEX <- integrate(\n  g,\n  lower = 1,\n  upper = Inf\n)$value\nEX\n\n\n[1] 1.5\n\nLa varianza\nLa varianza di una variabile aleatoria continua \\(Y\\) avente una distribuzione di densità \\(f_Y(y)\\) è\n\\[\nVar(Y) = \\sigma^2_Y = \\int_a^b (y - \\mu_Y)^2 f_Y(y) dy.\n\\]\nPer trovare la soluzione del problema del calcolo della varianza di una variabile aleatoria continua utilizzeremo qui la formula alternativa della varianza:\n\\[\nVar(Y) = \\mathbb{E}(Y^2) - \\mathbb{E}(Y)^2.\n\\] Per il problema che stiamo discutendo, iniziamo a definire la funzione composta \\(x^2\\):\n\n\nh <- function(x) x^2 * f(x)\n\n\n\nCalcoliamo poi l’area sottesa dal grafico di tale funzione. Applicando la formula della varianza otteniamo infine il risultato desiderato:\n\n\nVarX <- integrate(\n  h,\n  lower = 1,\n  upper = Inf\n)$value - EX^2 \nVarX\n\n\n[1] 0.75\n\n\n\n\n",
    "preview": "posts/2021-03-20-valore-atteso-e-varianza-di-variabili-aleatorie-continue/preview.png",
    "last_modified": "2021-03-20T11:39:05+01:00",
    "input_file": {},
    "preview_width": 608,
    "preview_height": 730
  },
  {
    "path": "posts/2021-03-19-distribuzioni-di-probabilit-discrete-3/",
    "title": "Distribuzioni di probabilità discrete (3)",
    "description": "Usiamo `R` per calcolare la covarianza di due variabili aleatorie discrete.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-20",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\n\nContents\nTL; DR\nLa distribuzioni di probabilità congiunta\nValore atteso\nCovarianza\nCorrelazione\n\nTL; DR\nIn questo post ci porremo il problema di calcolare la covarianza e la correlazione di due variabili aleatorie discrete, utilizzando l’informazione fornita dalla distribuzione di probabilità congiunta. Vedremo come si possa usare R per semplificare i calcoli.\nLa distribuzioni di probabilità congiunta\nCarichiamo i pacchetti necessari:\n\n\nlibrary(\"prob\")\nlibrary(\"distrEx\")\n\n\n\nConsideriamo l’esperimento casuale che corrisponde al lancio di due dadi bilanciati. Creiamo lo spazio campionario di questo esperimento casuale e definiamo su di esso le seguenti variabili aleatorie:\nU: somma dei punti dei due dadi,\nV: 1 se i punti del lancio del primo dado sono minori di 4, 0 altrimenti.\nCome nei post precedenti, otteniamo un elenco di tutti gli eventi elementari dello spazio campionario usando le istruzioni seguenti:\n\n\nS <- rolldie(2, nsides = 6, makespace = TRUE)\nS <- addrv(S, U = X1+X2, V = ifelse(X1 < 4, 1, 0))\nS\n\n\n   X1 X2  U V      probs\n1   1  1  2 1 0.02777778\n2   2  1  3 1 0.02777778\n3   3  1  4 1 0.02777778\n4   4  1  5 0 0.02777778\n5   5  1  6 0 0.02777778\n6   6  1  7 0 0.02777778\n7   1  2  3 1 0.02777778\n8   2  2  4 1 0.02777778\n9   3  2  5 1 0.02777778\n10  4  2  6 0 0.02777778\n11  5  2  7 0 0.02777778\n12  6  2  8 0 0.02777778\n13  1  3  4 1 0.02777778\n14  2  3  5 1 0.02777778\n15  3  3  6 1 0.02777778\n16  4  3  7 0 0.02777778\n17  5  3  8 0 0.02777778\n18  6  3  9 0 0.02777778\n19  1  4  5 1 0.02777778\n20  2  4  6 1 0.02777778\n21  3  4  7 1 0.02777778\n22  4  4  8 0 0.02777778\n23  5  4  9 0 0.02777778\n24  6  4 10 0 0.02777778\n25  1  5  6 1 0.02777778\n26  2  5  7 1 0.02777778\n27  3  5  8 1 0.02777778\n28  4  5  9 0 0.02777778\n29  5  5 10 0 0.02777778\n30  6  5 11 0 0.02777778\n31  1  6  7 1 0.02777778\n32  2  6  8 1 0.02777778\n33  3  6  9 1 0.02777778\n34  4  6 10 0 0.02777778\n35  5  6 11 0 0.02777778\n36  6  6 12 0 0.02777778\n\nLe istruzioni precedenti specificano, in corrispondenza di ogni punto dello spazio campionario (ovvero, in ciascuna riga del data.frame che viene generato), il valore assunto dalle due variabili aleatorie che sono state definite.\nLa descrizione dello spazio campionario fornita da R è corretta: questo esperimento casuale produce infatti 6 \\(\\times\\) 6 esiti (eventi elementari) possibili. Ma si noti che alcune righe del data.frame si ripetono più volte. Possiamo dunque semplificare tale descrizione nel modo seguente:\n\n\nUV <- marginal(S, vars = c(\"U\", \"V\")) \nUV\n\n\n    U V      probs\n1   5 0 0.02777778\n2   6 0 0.05555556\n3   7 0 0.08333333\n4   8 0 0.08333333\n5   9 0 0.08333333\n6  10 0 0.08333333\n7  11 0 0.05555556\n8  12 0 0.02777778\n9   2 1 0.02777778\n10  3 1 0.05555556\n11  4 1 0.08333333\n12  5 1 0.08333333\n13  6 1 0.08333333\n14  7 1 0.08333333\n15  8 1 0.05555556\n16  9 1 0.02777778\n\nL’elenco dei valori che le due variabili aleatorie \\(U\\) e \\(V\\) possono assumere, insieme alla probabilità del loro verificarsi, costituisce la distribuzione di probabilità congiunta delle due variabili aleatorie.\nÈ anche possibile presentare la distribuzione di probabilità congiunta in forma tabulare. A tale fine possiamo utilizzare la funzione xtabs():\n\n\nxtabs(round(probs, 3) ~ U + V, data = UV)\n\n\n    V\nU        0     1\n  2  0.000 0.028\n  3  0.000 0.056\n  4  0.000 0.083\n  5  0.028 0.083\n  6  0.056 0.083\n  7  0.083 0.083\n  8  0.083 0.056\n  9  0.083 0.028\n  10 0.083 0.000\n  11 0.056 0.000\n  12 0.028 0.000\n\nRipetiamo ora il processo precedente chiedendo alla funzione marginal() di calcolare le due distribuzioni marginali univariate:\n\n\npu <- marginal(S, vars = \"U\")\npu\n\n\n    U      probs\n1   2 0.02777778\n2   3 0.05555556\n3   4 0.08333333\n4   5 0.11111111\n5   6 0.13888889\n6   7 0.16666667\n7   8 0.13888889\n8   9 0.11111111\n9  10 0.08333333\n10 11 0.05555556\n11 12 0.02777778\n\ne\n\n\npv <- marginal(S, vars = \"V\")\npv\n\n\n  V probs\n1 0   0.5\n2 1   0.5\n\nIn maniera equivalente, lo stesso risultato si trova applicando le funzioni rowSums() e colSums() all’oggetto creato da xtabs():\n\n\ntemp <- xtabs(probs ~ U + V, data = UV)\nrowSums(temp)\n\n\n         2          3          4          5          6          7 \n0.02777778 0.05555556 0.08333333 0.11111111 0.13888889 0.16666667 \n         8          9         10         11         12 \n0.13888889 0.11111111 0.08333333 0.05555556 0.02777778 \n\ne\n\n\ncolSums(temp)\n\n\n  0   1 \n0.5 0.5 \n\nValore atteso\nCalcoliamo ora il valore atteso delle due variabili aleatorie. Il valore atteso U è\n\n\nU <- DiscreteDistribution(supp = pu$U, prob = pu$probs)\nmu_u <- E(U)\nmu_u\n\n\n[1] 7\n\nIl valore atteso di V è:\n\n\nV <- DiscreteDistribution(supp = pv$V, prob = pv$probs)\nmu_v <- E(V)\nmu_v\n\n\n[1] 0.5\n\nCovarianza\nUtilizzando le informazioni precedenti possiamo ora calcolare la covarianza tra \\(U\\) e \\(V\\).\nLa formula della covarianza\n\\[\n\\sigma_{xy} = \\sum_i \\big(x_i - \\mathbb{E}(x)\\big)\\big(y_i - \\mathbb{E}(y)\\big) \\cdot p_i(x,y)\n\\] può essere implementata in R nel modo seguente:\n\n\ns_uv <- sum((UV$U - mu_u) * (UV$V - mu_v) * UV$probs)\ns_uv\n\n\n[1] -0.75\n\nLo stesso risultato si ottiene usando la formula alternativa per il calcolo della covarianza:\n\\[\n\\sigma_{xy} = \\mathbb{E}(xy) -\\mathbb{E}(x)\\mathbb{E}(y)\n\\] ovvero\n\n\nsum((UV$U * UV$V) * UV$probs) - mu_u * mu_v\n\n\n[1] -0.75\n\nCorrelazione\nConoscendo la covarianza è possibile calcolare la correlazione. La correlazione infatti è una covarianza standardizzata:\n\\[\n\\rho_{xy} = \\frac{\\sigma_{xy}}{\\sigma_x\\sigma_y}\n\\]\nPer standardizzare dobbiamo dividere per le due deviazioni standard. Iniziamo dunque a calcolare le varianze delle due variabili aleatorie \\(U\\) e \\(V\\):\n\n\nv_u <- sum((pu$U - mu_u)^2 * pu$probs)\nv_u\n\n\n[1] 5.833333\n\nv_v <- sum((pv$V - mu_v)^2 * pv$probs)\nv_v\n\n\n[1] 0.25\n\noppure, in maniera equivalente\n\n\nvar(U)\n\n\n[1] 5.833333\n\nvar(V)\n\n\n[1] 0.25\n\nAbbiamo ora tutte le informazioni necessarie per il calcolo della correlazione:\n\n\ns_uv / sqrt(var(U) * var(V))\n\n\n[1] -0.621059\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-20T11:38:08+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-19-distribuzioni-di-probabilit-discrete-2/",
    "title": "Distribuzioni di probabilità discrete (2)",
    "description": "Usiamo `R` per calcolare il valore atteso e la varianza di variabili aleatorie discrete.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-19",
    "categories": [
      "Psicometria",
      "R"
    ],
    "contents": "\nTL; DR\nIn questo post esamineremo nuovamente la nozione di indipendenza nel caso di due variabili aleatorie definite su uno spazio campionario discreto. Di tali variabili aleatorie discrete calcoleremo poi il valore atteso e la varianza.\nDistribuzioni di probabilità marginali\nConsideriamo l’esperimento casuale corrispondente al lancio di due dadi bilanciati.\nCarichiamo il pacchetto prob\n\n\nlibrary(\"prob\")\n\n\n\ne creiamo lo spazio campionario di questo esperimento casuale:\n\n\nS <- rolldie(2, nsides = 6, makespace = TRUE)\nS\n\n\n   X1 X2      probs\n1   1  1 0.02777778\n2   2  1 0.02777778\n3   3  1 0.02777778\n4   4  1 0.02777778\n5   5  1 0.02777778\n6   6  1 0.02777778\n7   1  2 0.02777778\n8   2  2 0.02777778\n9   3  2 0.02777778\n10  4  2 0.02777778\n11  5  2 0.02777778\n12  6  2 0.02777778\n13  1  3 0.02777778\n14  2  3 0.02777778\n15  3  3 0.02777778\n16  4  3 0.02777778\n17  5  3 0.02777778\n18  6  3 0.02777778\n19  1  4 0.02777778\n20  2  4 0.02777778\n21  3  4 0.02777778\n22  4  4 0.02777778\n23  5  4 0.02777778\n24  6  4 0.02777778\n25  1  5 0.02777778\n26  2  5 0.02777778\n27  3  5 0.02777778\n28  4  5 0.02777778\n29  5  5 0.02777778\n30  6  5 0.02777778\n31  1  6 0.02777778\n32  2  6 0.02777778\n33  3  6 0.02777778\n34  4  6 0.02777778\n35  5  6 0.02777778\n36  6  6 0.02777778\n\nDefiniamo le seguenti variabili aleatorie:\nU: somma dei punti dei due dadi,\nV: 1 se i punti del lancio del primo dado sono minori di 4, 0 altrimenti.\n\n\nS <- addrv(S, U = X1+X2, V = ifelse(X1 < 4, 1, 0))\nhead(S)\n\n\n  X1 X2 U V      probs\n1  1  1 2 1 0.02777778\n2  2  1 3 1 0.02777778\n3  3  1 4 1 0.02777778\n4  4  1 5 0 0.02777778\n5  5  1 6 0 0.02777778\n6  6  1 7 0 0.02777778\n\nCalcoliamo la distribuzione marginale di \\(U\\):\n\n\npu <- marginal(S, vars = \"U\")\npu\n\n\n    U      probs\n1   2 0.02777778\n2   3 0.05555556\n3   4 0.08333333\n4   5 0.11111111\n5   6 0.13888889\n6   7 0.16666667\n7   8 0.13888889\n8   9 0.11111111\n9  10 0.08333333\n10 11 0.05555556\n11 12 0.02777778\n\nVerifichiamo:\n\n\nsum(pu$U * pu$probs)\n\n\n[1] 7\n\nLo stesso per \\(V\\):\n\n\npv <- marginal(S, vars = \"V\")\npv\n\n\n  V probs\n1 0   0.5\n2 1   0.5\n\nDistribuzione di probabilità congiunta\nCreiamo ora la distribuzione di probabilità congiunta delle variabili \\(U\\) e \\(V\\):\n\n\npj <- marginal(S, vars = c(\"U\", \"V\"))\npj\n\n\n    U V      probs\n1   5 0 0.02777778\n2   6 0 0.05555556\n3   7 0 0.08333333\n4   8 0 0.08333333\n5   9 0 0.08333333\n6  10 0 0.08333333\n7  11 0 0.05555556\n8  12 0 0.02777778\n9   2 1 0.02777778\n10  3 1 0.05555556\n11  4 1 0.08333333\n12  5 1 0.08333333\n13  6 1 0.08333333\n14  7 1 0.08333333\n15  8 1 0.05555556\n16  9 1 0.02777778\n\nIndipendenza\nChiediamoci: \\(U\\) e \\(V\\) sono indipendenti?\n\n\npu[pu$U == 3, ]$probs * pv[pv$V == 1, ]$probs\n\n\n[1] 0.02777778\n\npj[pj$U == 3 & pj$V == 1, ]$probs\n\n\n[1] 0.05555556\n\nQuindi, la risposta è negativa.\nValore atteso e varianza\nConsideriamo la variabile \\(U\\). Calcoliamo il valore atteso e la varianza. Per fare questo, utilizzeremo le funzioni del pacchetto distrEx.\n\n\nlibrary(\"distrEx\")\n\n\n\nIniziamo con il valore atteso:\n\n\nX <- DiscreteDistribution(supp = pu$U, prob = pu$probs)\nmu <- E(X)\nmu\n\n\n[1] 7\n\nVerifichiamo:\n\n\nsum(pu$U * pu$probs)\n\n\n[1] 7\n\nCalcoliamo ora la varianza:\n\n\nvar(X)\n\n\n[1] 5.833333\n\nVerifichiamo:\n\n\nsum((pu$U - mu)^2 * pu$probs)\n\n\n[1] 5.833333\n\nInfine, la deviazione standard:\n\n\nsd(X)\n\n\n[1] 2.415229\n\nConclusioni\nLe funzioni fornite dai pacchetti prob e distrEx ci consentono di trovare la soluzione dei più comuni problemi “scolastici” relativi alle variabili aletorie discrete. Una descrizione delle funzionalità di questi pacchetti è fornita, per esempio, in questo documento.\n\n\n\n",
    "preview": "posts/2021-03-19-distribuzioni-di-probabilit-discrete-2/preview.png",
    "last_modified": "2021-03-20T08:33:59+01:00",
    "input_file": {},
    "preview_width": 682,
    "preview_height": 428
  },
  {
    "path": "posts/2021-03-19-usare-r-per-risolvere-gli-esercizi-sulle-distribuzioni-di-probabilit-discrete/",
    "title": "Distribuzioni di probabilità discrete (1)",
    "description": "È possibile usare le funzioni contenute in alcuni pacchetti `R` per facilitare la soluzione degli esercizi sulle distribuzioni di probabilità discrete.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-19",
    "categories": [
      "Psicometria",
      "R"
    ],
    "contents": "\n\nContents\nTL; DR\nIl lancio di un dado\nIl lancio di due dadi\nProbabilità condizionata\nIndipendenza\n\nTL; DR\nUtilizzeremo qui le funzioni fornite dal pacchetto prob per affrontare alcuni comuni problemi di calcolo delle probabilità nel caso in cui lo spazio campionario è costitutito da un insieme finito di eventi elementari aventi tutti la stessa probabilità di verificarsi.\n\n\nlibrary(\"prob\")\n\n\n\nIl lancio di un dado\nConsideriamo l’esperimento casuale consistente nel lancio di dado bilanciato e utilizziamo la funzione rolldie():\n\n\nrolldie(1, makespace = TRUE)\n\n\n  X1     probs\n1  1 0.1666667\n2  2 0.1666667\n3  3 0.1666667\n4  4 0.1666667\n5  5 0.1666667\n6  6 0.1666667\n\nLa funzione rolldie() crea un dataframe in cui ciascuna riga corrisponde ad un punto dello spazio campionario (cioè un evento elementare). La colonna probs riporta la probabilità associata a ciascun punto dello spazio campionario.\nIl lancio di due dadi\nOvviamente possiamo essere più ambiziosi e costruire, ad esempio, lo spazio campionario associato all’esperimento casuale che consiste nel lancio di due dadi bilanciati:\n\n\nS <- rolldie(2, makespace = TRUE)\nS\n\n\n   X1 X2      probs\n1   1  1 0.02777778\n2   2  1 0.02777778\n3   3  1 0.02777778\n4   4  1 0.02777778\n5   5  1 0.02777778\n6   6  1 0.02777778\n7   1  2 0.02777778\n8   2  2 0.02777778\n9   3  2 0.02777778\n10  4  2 0.02777778\n11  5  2 0.02777778\n12  6  2 0.02777778\n13  1  3 0.02777778\n14  2  3 0.02777778\n15  3  3 0.02777778\n16  4  3 0.02777778\n17  5  3 0.02777778\n18  6  3 0.02777778\n19  1  4 0.02777778\n20  2  4 0.02777778\n21  3  4 0.02777778\n22  4  4 0.02777778\n23  5  4 0.02777778\n24  6  4 0.02777778\n25  1  5 0.02777778\n26  2  5 0.02777778\n27  3  5 0.02777778\n28  4  5 0.02777778\n29  5  5 0.02777778\n30  6  5 0.02777778\n31  1  6 0.02777778\n32  2  6 0.02777778\n33  3  6 0.02777778\n34  4  6 0.02777778\n35  5  6 0.02777778\n36  6  6 0.02777778\n\nIn questo caso, il dataframe \\(S\\) è costituito da \\(6 \\times 6\\) righe:\n\n\nnrow(S)\n\n\n[1] 36\n\nSullo spazio campionario \\(S\\) definiamo ora gli eventi \\(A\\) e \\(B\\). Siano \\(A\\) e \\(B\\) due eventi in \\(S\\) tali per cui\n\\(A\\): i due lanci producono lo stesso risultato,\n\\(B\\): la somma dei punti dei due lanci è maggiore o uguale a 8.\nPer identificare tali eventi è sufficiente estrarre dal dataframe S le righe (eventi elementari) che corrispondono alla definizione dei due eventi:\n\n\nA <- subset(S, X1 == X2)\nB <- subset(S, X1 + X2 >= 8)\n\n\n\n\n\nA\n\n\n   X1 X2      probs\n1   1  1 0.02777778\n8   2  2 0.02777778\n15  3  3 0.02777778\n22  4  4 0.02777778\n29  5  5 0.02777778\n36  6  6 0.02777778\n\nLa probabilità del verificarsi dell’evento \\(A\\) è\n\n\n6 / 36\n\n\n[1] 0.1666667\n\nIn R dobbiamo sommare i valori della colonna probs e questo viene fatto dalla funzione Prob() che prende come argomento l’oggetto che corrisponde al sottoinsieme di \\(S\\) che abbiamo definito:\n\n\nProb(A)\n\n\n[1] 0.1666667\n\nFacciamo la stessa cosa per \\(B\\):\n\n\nnrow(B)\n\n\n[1] 15\n\nDunque, la probabilità di \\(B\\) è\n\n\n15 / 36\n\n\n[1] 0.4166667\n\novvero\n\n\nProb(B)\n\n\n[1] 0.4166667\n\nProbabilità condizionata\nLa probabilità condizionata di \\(A\\) dato \\(B\\) corrisponde alla somma delle probabilità degli eventi elementari in \\(A\\), se consideriamo solo il sottoinsieme \\(B\\). Esaminiamo dunque \\(B\\):\n\n\nB\n\n\n   X1 X2      probs\n12  6  2 0.02777778\n17  5  3 0.02777778\n18  6  3 0.02777778\n22  4  4 0.02777778\n23  5  4 0.02777778\n24  6  4 0.02777778\n27  3  5 0.02777778\n28  4  5 0.02777778\n29  5  5 0.02777778\n30  6  5 0.02777778\n32  2  6 0.02777778\n33  3  6 0.02777778\n34  4  6 0.02777778\n35  5  6 0.02777778\n36  6  6 0.02777778\n\nCi chiediamo quali righe nel dataframe B sono tali per cui X1 == X2:\n\n\nB[B$X1 == B$X2, ]\n\n\n   X1 X2      probs\n22  4  4 0.02777778\n29  5  5 0.02777778\n36  6  6 0.02777778\n\nLa soluzione è dunque data dalla somma dei valori probs nel dataframe riportato sopra, la quale va divisa per la somma dei valori probs contenuti nel dataframe B:\n\n\nsum(B[B$X1 == B$X2, ]$probs) / sum(B$probs)\n\n\n[1] 0.2\n\nTale risultato può essere ottenuto usando la seguente istruzione:\n\n\nProb(A, given = B)\n\n\n[1] 0.2\n\nÈ dunque facile trovare, seguendo la stessa procedura, la probabilità \\(P(B \\mid A)\\):\n\n\nProb(B, given = A)\n\n\n[1] 0.5\n\nIndipendenza\nChiediamoci ora se \\(A\\) e \\(B\\) sono indipendenti.\nPer affrontare questo problema dobbiamo calcolare la probabilità \\(P(A \\cap B)\\). Per fare questo dobbiamo selezionare le righe di \\(S\\) nelle quali la colonna X1 è uguale alla colonna X2 e poi sommare i valori di probabilità contenuti nella colonna probs. Usiamo la funzione intersect():\n\n\nintersect(A, B)\n\n\n   X1 X2      probs\n22  4  4 0.02777778\n29  5  5 0.02777778\n36  6  6 0.02777778\n\nLa probabilità dell’intersezione \\(A \\cap B\\) è dunque uguale a\n\n\n3 / 36\n\n\n[1] 0.08333333\n\novvero:\n\n\nProb(intersect(A, B))\n\n\n[1] 0.08333333\n\nSiamo ora nelle condizioni di decidere se \\(A\\) e \\(B\\) sono o meno indipendenti. Sappiamo che due eventi sono indipendenti se \\(P(A \\cap B) = P(A) P(B)\\). Verifichiamo:\n\n\nProb(A) * Prob(B)\n\n\n[1] 0.06944444\n\nil che non corrisponde al valore 0.0833333. Possiamo dunque concludere che gli eventi \\(A\\) e \\(B\\) non sono indipendenti.\n\n\n\n",
    "preview": "posts/2021-03-19-usare-r-per-risolvere-gli-esercizi-sulle-distribuzioni-di-probabilit-discrete/preview.png",
    "last_modified": "2021-03-20T11:39:55+01:00",
    "input_file": {},
    "preview_width": 1280,
    "preview_height": 586
  },
  {
    "path": "posts/2021-03-18-varianza-e-valore-atteso-una-semplice-simulazione-in-r/",
    "title": "Varianza e valore atteso",
    "description": "Una semplice simulazione in R",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-18",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\n\n\nlibrary(\"tidyverse\", warn.conflicts = FALSE)\n\n\n\nProblema\nSupponiamo di sapere che, sulla base dei dati di un campione molto grande, possiamo stabilire che nella popolazione oncologica, i punteggi di un test psicometrico atto a misurare l’astenia seguono la distribuzione di massa di probabilità indicata qui sotto:\nPunteggio\nProbabilità\n1\n0.1\n2\n0.5\n3\n0.3\n4\n0.1\nLaddove i valori indicano la frequenza con la quale tale sintomo, riduzione di energia dell’individuo, si manifesta. Per esempio, potremmo avere che 4 corrisponde a “molto spesso”, 3 corrisponde a “spesso”, 2 corrisponde a “alle volte” e 1 corrisponde a “raramente o mai”.\nRappresentazione grafica della distribuzione di massa di probabilità\n\n\n# valori della variabile aleatoria\ny <- 1:4\n\n# probabilità\npy <- c(0.1, 0.5, 0.3, 0.1)\n\nd <- data.frame(y, py)\n\nd %>% \n  ggplot(aes(y, py)) +\n  geom_point(size = 4) +\n  geom_linerange(aes(x=y, ymax=py, ymin=0.0)) +\n  ylim(0, 0.55) +\n  labs(\n    title = \"Astenia nella popolazione oncologica\",\n    x = \"Punteggio del test\",\n    y = \"Probabilità\"\n  )\n\n\n\n\nPoniamoci ora il problema di trovare il valore atteso del punteggio di astenia e la varianza del punteggio di astenia di questo ipotetico test. Soprattutto, ci poniamo il problema di assegnare un’interpretazione inuitiva a questi concetti.\nValore atteso\nLa definizione di valore atteso della variabile aleatoria \\(y\\) è\n\\[\n\\mathbb{E}(y) = \\sum_{i=1}^n y_i \\cdot p_i\n\\]\nil che, per i dati del problema, significa\n\\[\n1 \\cdot 0.1 + 2 \\cdot 0.5 + 3 \\cdot 0.3 + 4 \\cdot 0.1 = 2.4\n\\]\n\n\n1 * 0.1 + 2 * 0.5 + 3 * 0.3 + 4 * 0.1\n\n\n[1] 2.4\n\novvero\n\n\nev_y <- sum(y * py)\nev_y\n\n\n[1] 2.4\n\nInterpretazione\nMa che significa, in pratica, il valore atteso? Per rispondere a questa domanda, eseguiamo una simulazione. Ovvero, estraiamo un campione molto grade di osservazioni da una popolazione che ha le caratteristiche descritte, ovvero nella quale il valore 1 è presente nel 10% delle osservazioni, il valore 2 è presente nel 50% delle osservazioni, eccetera.\nImplemento qui di seguito una funzione che consente di estrarre dei campioni casuali, di qualunque ampiezza, da una siffatta popolazione:\n\n\nsample_distr = function(n) { \n  sample(\n    x = 1:4, \n    n, \n    replace = TRUE, \n    prob = c(0.1, 0.5, 0.3, 0.1)\n  ) \n}\n\n\n\nEstraggo ora un campione di ampiezza \\(n\\) = 100,000 e lo chiamo x:\n\n\nx <- sample_distr(1e5)\n\n\n\nCalcolo ora la media di tale campione:\n\n\nmean(x)\n\n\n[1] 2.39906\n\nIl risultato della simulazione mostra che la media di un capione molto grande estratto dalla popolazione specificata è (quasi) uguale al valore atteso della variabile aleatoria. Questo ci consente di assegnare un’inerpretazione intuitiva al concetto di valore atteso:\n\nil valore atteso è la media aritmetica di un numero molto grande di realizzazioni della variabile aleatoria.\n\nVarianza\nLa definizione di varianza di una variabile aleatoria è la seguente:\n\\[\nVar(y) = \\sum_{i=1}^n (y_i - \\mu)^2 \\cdot p_i\n\\]\nImplementiamo la formula in R per i dati del problema:\n\\[\n(1 - 4.4)^2 \\cdot 0.1 + (2 - 4.4)^2 \\cdot 0.5 +(3 - 4.4)^2 \\cdot 0.3 +(4 - 4.4)^2 \\cdot 0.1 = 0.64\n\\]\novvero\n\n\nsum((y - ev_y)^2 * py)\n\n\n[1] 0.64\n\nFormula alternativa\nUsiamo ora la formula alternativa per il calcolo della varianza:\n\\[\nVar(y) = \\mathbb{E}(y^2) - \\mathbb{E}(y)^2= \\sum_{i=1}^n y_i^2\\cdot p_i - \\Bigg(\\sum_{i=1}^n y_i \\cdot p_i\\Bigg)^2\n\\]\n\n\nsum(y^2 * py) - ev_y^2\n\n\n[1] 0.64\n\nInterpretazione\nDi nuovo, ci chiediamo: che cosa è, in pratica, la varianza di una variabile aleatoria? Possiamo rispondere a questa domanda ripetendo il ragionamento fatto sopra.\nAvendo extratto 100,000 valori dalla popolazione di riferimento, calcoliamo la varianza di tali valori, usando la formula della statistica descrittiva:\n\n\nvar(x)\n\n\n[1] 0.6383175\n\net voilà! Il valore che abbiamo trovato, utilizzando la formula della statistica descrittiva (anche senza correggere il denominatore, dato che \\(n\\) è molto grande) ci dà un risultato molto simile a quello della varianza della variabile aleatoria.\nQuindi, anche in questo caso, l’interpretazione è semplice:\n\nla varianza di una variabile aleatoria è la varianza (nel senso della statistica descrittiva) di un numero molto grande di realizzazioni della variabile aleatoria.\n\nCome sempre, è più semplice utilizzare tale valore prendendo la radice quadrata: la deviazione standard, infatti, è espressa nella stessa unità di misura dei valori grezzi della variabile cosiderata.\n\n\n\n",
    "preview": "posts/2021-03-18-varianza-e-valore-atteso-una-semplice-simulazione-in-r/varianza-e-valore-atteso-una-semplice-simulazione-in-r_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-19T06:48:35+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-03-13-la-struttura-del-progetto/",
    "title": "La struttura del progetto",
    "description": "Salvare e assegnare un nome ai documenti di un progetto.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-13",
    "categories": [
      "R",
      "Psicometria",
      "tesi"
    ],
    "contents": "\nDi seguito riporto il link ad un breve video-tutorial che cerca di rispondere alle seguenti domande: come organizzo tutto il materiale che fa parte di un progetto? Quali sono i principi che devo seguire per assegnare i nomi ai file? Come devo organizzare i file nelle cartelle? L’obiettivo è quello di immagazzinare sul computer il lavoro che abbiamo fatto in maniera tale che, in futuro, sarà facile recuperare quello che ci serve. E in modo tale che sia facile lavorare al nostro progetto nel presente.\nLe considerazioni che faccio fanno riferimento a delle raccomandazioni che “sono nell’aria”, ovvero, che sono condivise da molte persone. Questo materiale è stato organizzato in una serie di video youtube da Danielle Navarro e io mi limito a commentare brevemente quello che lei dice. Ovviamente, invece di seguire il mio video-tutorial, potete guardare direttamente i video di Danielle Navarro.\nUna cosa che mi sono dimenticato di dire nel mio video, e che invece è presente nei video youtube, è la seguente: dove dobbiamo salvare la cartella che contiene tutto il materiale di un progetto? Pessime risposte a questa domanda sono: il Desktop oppure la cartella di Download. Peggio di così non si può fare. Perché sia il Desktop sia la cartella Download contengono informazioni transienti, ovvero file che butterete via ad un certo punto – presto, si spera. Invece la cartella che contiene il vostro progetto contiene il frutto del vostro lavoro – e certamente non volete cancellarla per sbaglio. Quindi, un’idea molto migliore è quella di salvare la cartella del progetto nella cloud, ovvero, sul vostro comupter in cartelle come OneDrive o Dropbox.\nSpero che questo sia utile.\n\n\n\n",
    "preview": "posts/2021-03-13-la-struttura-del-progetto/preview.png",
    "last_modified": "2021-03-19T21:06:34+01:00",
    "input_file": {},
    "preview_width": 568,
    "preview_height": 912
  },
  {
    "path": "posts/2021-03-11-manipolazione-dei-dati-con-dplyr/",
    "title": "Manipolazione dei dati con dplyr",
    "description": "Tutorial sull'uso delle funzionalità di base di dplyr per la manipolazione dei dati.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-11",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nAggiungo qui il link ad un video-tutorial che ho preparato relativamente alla manipolaizone dei dati usando le funzioni del pacchetto dplyr.\nNel video non faccio altro che commentare un tutorial predisposto da Allison Horst e disponibile seguendo questo link. Il tutorial di Allison Horst è fatto benissimo e non vedo ragioni di tradurlo o cambiarlo in qualche modo. Inoltre, se andate nella pagina web che ho indicato sopra, potete anche fare degli esercizi che vi consentono di verificare se avete capito come utilizzare in pratica le istruzioni R che vengono discusse – le risposte agli esercizi sono immediatamente disponibili il che rende il tutorial di Allison Horst un utilissimo strumento di apprendimento. Buon divertimento!\n\n\n\n",
    "preview": "posts/2021-03-11-manipolazione-dei-dati-con-dplyr/preview.png",
    "last_modified": "2021-03-11T13:12:28+01:00",
    "input_file": {},
    "preview_width": 978,
    "preview_height": 663
  },
  {
    "path": "posts/2021-03-10-introduzione-a-r-markdown/",
    "title": "Introduzione a R Markdown",
    "description": "Creare un documento R Markdown con R Studio.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-10",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nPosto qui il link ad un breve video-tutorial sull’uso di R Markdown.\nLa migliore descrizione del flusso di lavoro (workflow) con R Markdown è fornita in questo capitolo di R for Data Science.\nPer chi ha bisogno di un’introduzione, risultano sicuramente utili anche le slide di Danielle Navarro.\n\n\n\n",
    "preview": "posts/2021-03-10-introduzione-a-r-markdown/preview.png",
    "last_modified": "2021-03-12T06:49:05+01:00",
    "input_file": {},
    "preview_width": 872,
    "preview_height": 1432
  },
  {
    "path": "posts/2021-03-10-notazione-sommatoria/",
    "title": "Notazione sommatoria",
    "description": "Simbolo di somma.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-10",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\n\nIl simbolo \\(\\sum_{i=1}^{\\infty}\\) indica che dobbiamo assegnare al numero intero \\(i\\) tutti i suoi valori \\(1, 2, 3, ...\\) ed eseguire la somma dei termini. (Jean-Baptiste Joseph Fourier)\n\nLe somme si incontrano costantemente in svariati contesti matematici e statistici quindi abbiamo bisogno di una notazione adeguata che ci consenta di gestirle. Si veda, ad esempio, Wikipedia.\nSimbolo di somma (sommatorie)\nLa somma dei primi \\(n\\) numeri interi può essere scritta come \\(1+2+\\dots+(n-1)+n\\), dove `\\(\\dots\\)’ ci dice di completare la sequenza definita dai termini che vengono prima e dopo. Ovviamente, una notazione come \\(1+7+\\dots+73.6\\) non ha alcun senso senza qualche altro tipo di precisazione. In generale, si incontrano delle somme nella forma\n\\[\\begin{equation}\nx_1+x_2+\\dots+x_n,\n\\end{equation}\\]\ndove \\(x_i\\) è un numero che è stato definito altrove. La notazione precedente, che fa uso dei tre puntini di sospensione, è utile in alcuni contesti ma in altri risulta ambigua. Pertanto la notazione di uso corrente è del tipo\n\\[\\begin{equation}\n  \\sum_{i=1}^n x_i\n\\end{equation}\\]\n e si legge ``sommatoria per \\(i\\) che va da \\(1\\) a \\(n\\) di \\(x_i\\).’’ Il simbolo \\(\\sum\\) (lettera sigma maiuscola dell’alfabeto greco) indica l’operazione di somma, il simbolo \\(x_i\\) indica il generico addendo della sommatoria, le lettere \\(1\\) ed \\(n\\) indicano i cosiddetti , ovvero l’intervallo (da \\(1\\) fino a \\(n\\) estremi inclusi) in cui deve variare l’indice \\(i\\) allorché si sommano gli addendi \\(x_i\\). Solitamente l’estremo inferiore è \\(1\\) ma potrebbe essere qualsiasi altri numero \\(m < n\\). Quindi \\[\n  \\sum_{i=1}^n x_i = x_1 + x_{2} + \\dots + x_{n}.\n\\] Per esempio, se i valori \\(x\\) sono \\(\\{3, 11, 4, 7\\}\\), si avrà \\[\n  \\sum_{i=1}^4 x_i = 3+11+4+7 = 25 \n\\] laddove \\(x_1 = 3\\), \\(x_2 = 11\\), eccetera. La quantità \\(x_i\\) nella formula precedente si dice l’ della sommatoria, mentre la variabile \\(i\\), che prende i valori naturali successivi indicati nel simbolo, si dice  della sommatoria.\nLa notazione di sommatoria può anche essere fornita nella forma seguente\n\\[\\begin{equation}\n  \\sum_{P(i)} x_i\n\\end{equation}\\]\ndove \\(P(i)\\) è qualsiasi proposizione riguardante \\(i\\) che può essere vera o falsa. Quando è ovvio che si vogliono sommare tutti i valori di \\(n\\) osservazioni, la notazione può essere semplificata nel modo seguente: \\(\\sum_{i} x_i\\) oppure \\(\\sum x_i\\). Al posto di \\(i\\) si possono trovare altre lettere: \\(k, j, l, \\dots\\),.\nManipolazione di somme\nÈ conveniente utilizzare le seguenti regole per semplificare i calcoli che coinvolgono l’operatore della sommatoria.\nProprietà 1\nLa sommatoria di \\(n\\) valori tutti pari alla stessa costante \\(a\\) è pari a \\(n\\) volte la costante stessa:\n\\[\n  \\sum_{i=1}^{n} a =  \\underbrace{a + a + \\dots + a}_{n~\\text{volte}} = n a.\n  \\]\nProprietà 2 (proprietà distributiva)\nNel caso in cui l’argomento contenga una costante, è possibile riscrivere la sommatoria. Ad esempio con \\[\n  \\sum_{i=1}^{n} a x_i =  a x_1 + a x_2 + \\dots + a x_n\n  \\] è possibile raccogliere la costante \\(a\\) e fare \\(a(x_1 +x_2 + \\dots + x_n)\\). Quindi possiamo scrivere \\[\n  \\sum_{i=1}^{n} a x_i =  a  \\sum_{i=1}^{n} x_i.\n  \\]\nProprietà 3 (proprietà associativa)\nNel caso in cui \\[\n  \\sum_{i=1}^{n} (a + x_i) =  (a + x_1) +  (a + x_1) + \\dots  (a + x_n)\n  \\] si ha che \\[\n  \\sum_{i=1}^{n} (a + x_i) =  n a + \\sum_{i=1}^{n} x_i.\n  \\] È dunque chiaro che in generale possiamo scrivere \\[\n  \\sum_{i=1}^{n} (x_i + y_i) =  \\sum_{i=1}^{n} x_i + \\sum_{i=1}^{n} y_i.\n  \\]\nProprietà 4\nSe deve essere eseguita un’operazione algebrica (innalzamento a potenza, logaritmo, ecc.) sull’argomento della sommatoria, allora tale operazione algebrica deve essere eseguita prima della somma. Per esempio,\n\\[\n\\sum_{i=1}^{n} x_i^2 = x_1^2 + x_2^2 + \\dots + x_n^2 \\neq \\left(\\sum_{i=1}^{n} x_i \\right)^2.\n\\]\nProprietà 5\nNel caso si voglia calcolare \\(\\sum_{i=1}^{n} x_i y_i\\), il prodotto tra i punteggi appaiati deve essere eseguito prima e la somma dopo:\n\\[\n\\sum_{i=1}^{n} x_i y_i = x_1 y_1 + x_2 y_2 + \\dots + x_n y_n,\n\\] infatti, \\(a_1 b_1 + a_2 b_2 \\neq (a_1 + a_2)(b_1 + b_2)\\).\nDoppia sommatoria}\nÈ possibile incontrare la seguente espressione in cui figurano una doppia sommatoria e un doppio indice:\n\\[\n\\sum_{i=1}^{n}\\sum_{j=1}^{m} x_{ij}.\n\\]\nLa doppia sommatoria comporta che per ogni valore dell’indice esterno, \\(i\\) da \\(1\\) ad \\(n\\), occorre sviluppare la seconda sommatoria per \\(j\\) da \\(1\\) ad \\(m\\). Quindi,\n\\[\n\\sum_{i=1}^{3}\\sum_{j=4}^{6} x_{ij} = (x_{1, 4} + x_{1, 5} + x_{1, 6}) + (x_{2, 4} + x_{2, 5} + x_{2, 6}) + (x_{3, 4} + x_{3, 5} + x_{3, 6}).\n\\]\nUn caso particolare interessante di doppia sommatoria è il seguente:\n\\[\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} x_i y_j\n\\]\nSi può osservare che nella sommatoria interna (quella che dipende dall’indice \\(j\\)), la quantità \\(x_i\\) è costante, ovvero non dipende dall’indice (che è \\(j\\)). Allora possiamo estrarre \\(x_i\\) dall’operatore di sommatoria interna e scrivere\n\\[\n\\sum_{i=1}^{n} \\left( x_i \\sum_{j=1}^{n} y_j \\right).\n\\]\nAllo stesso modo si può osservare che nell’argomento della sommatoria esterna la quantità costituita dalla sommatoria in \\(j\\) non dipende dall’indice \\(i\\) e quindi questa quantità può essere estratta dalla sommatoria esterna. Si ottiene quindi\n\\[\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} x_i y_j = \\sum_{i=1}^{n} \\left( x_i \\sum_{j=1}^{n} y_j \\right) = \\sum_{i=1}^{n}\\ x_i \\sum_{j=1}^{n} y_j.\n\\]\nEsercizio\nSi verifichi quanto detto sopra nel caso particolare di \\(x = \\{2, 3, 1\\}\\) e \\(y = \\{1, 4, 9\\}\\), svolgendo prima la doppia sommatoria per poi verificare che quanto così ottenuto sia uguale al prodotto delle due sommatorie.\nSoluzione\n\\[\\begin{align}\n\\sum_{i=1}^3 \\sum_{j=1}^3 x_i y_j &= x_1y_1 + x_1y_2 + x_1y_3 + \nx_2y_1 + x_2y_2 + x_2y_3 + \nx_3y_1 + x_3y_2 + x_3y_3 \\notag\\\\\n&= 2 \\times (1+4+9) + 3 \\times (1+4+9) + 2 \\times (1+4+9) = 84,\\notag\n\\end{align}\\] ovvero \\[\n(2 + 3 + 1) \\times (1+4+9) = 84.\n\\]\nSommatorie con R\nPer evitare errori di calcolo, possiamo usare R per risolvere questo tipo di problemi. I dati a cui facciamo riferimento sono codificati nella forma di un vettore, il che corrisponde semplicemente ad un insieme ordinato di numeri. Solitamente è ciò che chiamiamo variabile, ovvero quello che uno psicologo misura e vuole descrivere o analizzare in qualche modo. Per esempio, una variabile può corrispondere al QI di un insieme di individui. Abbiamo visto che, in R, possiamo definire questo insieme di dati usando la funzione c() (che crea un vettore).\nSupponiamo di avere misurato il QI di 5 persone e di avere ottenuto i risultati seguenti: 102, 98, 122, 109, 89.\nPer manipolare questi dati, dobbiamo prima renderli disponibili nel workspace della sessione di R:\n\n\nx <- c(102, 98, 122, 109, 89)\nx\n\n\n[1] 102  98 122 109  89\n\nSupponiamo di volere sommare questi valori:\n\\[\n\\sum_{i = 1}^5 x_i\n\\]\nSe sviluppiamo la notazione precedente, per i dati dell’esempio avremo\n\\[\n\\sum_{i = 1}^5 x_i = x_1 + x_2 + x_3 + x_4 + x_5\n\\]\nladdove\n\\[\nx_1 = 102 \\quad x_2 = 98 \\quad x_3 = 122 \\quad x_4 = 109 \\quad x_5 = 89.\n\\]\nIn R una sommatoria si svolge utilizzando la funzione sum(). Quindi, nel caso presente, avremo\n\n\nsum(x)\n\n\n[1] 520\n\nLa notazione della sommatoria viene utilizzata, per esempio, nel calcolo della media:\n\\[\n\\bar{x} = \\frac{\\sum_{i = 1}^{n} x_i}{n}\n\\]\nNella formula precedente, sommiamo prima i valori contenuti nel vettore x e poi dividiamo il risultato ottenuto per n = 5, ovvero 520 / 5 = 104.\nIn R abbiamo\n\n\nsum(x) / length(x)\n\n\n[1] 104\n\nladdove la funzione length(x) ci restituisce i numero di elementi che costituiscono il vettore x, ovvero 5 nel caso dell’esempio.\nIn maniera equivalente, per le proprietà delle sommatorie presentate sopra, la formula della media può essere scritta come\n\\[\n\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^{n} x_i = \\sum_{i = 1}^{n}\\frac{1}{n} x_i,\n\\]\nil che significa che possiamo prima moltiplicare ciascun elemento di x per 1/n e poi sommare, come indicato qui di seguito:\n\\[\n(1/5 \\times 102) + (1/5 \\times 98) + (1/5 \\times  122) + (1/5 \\times  109) + (1/5 \\times  89)\n\\]\nIn R questo diventa\n\n\nsum(1/5 * x)\n\n\n[1] 104\n\nperché\n\n\n1/5 * x\n\n\n[1] 20.4 19.6 24.4 21.8 17.8\n\ncorrisponde al vettore\n\\[\n(1/5 \\times 102) + (1/5 \\times 98) + (1/5 \\times  122) + (1/5 \\times  109) + (1/5 \\times  89)\n\\]\ndopodiché sommiamo utilizzando la funzione sum().\nLa cosa importante da ricordare è che le operazioni algebriche (in questo caso moltiplicare per 1/5), quando vengono applicate ad un vettore (nel nostro caso (102, 98, 122, 109, 89)) si calcolano elemento per elemento. Ovvero, a ciascun elemento viene applicata l’operazione algebrica indicata, cioè il valore 102 viene moltiplicato per 1/5, il valore 98 viene moltiplicato per 1/5, ecc.\n\n\n\n",
    "preview": "posts/2021-03-10-notazione-sommatoria/preview.png",
    "last_modified": "2021-03-12T06:51:12+01:00",
    "input_file": {},
    "preview_width": 1226,
    "preview_height": 736
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-1/",
    "title": "Introduzione a R (1)",
    "description": "Il primo di una serie di post che presentano la sintassi di base di R.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\n\nContents\nSintassi\nR: linguaggio + ambiente\nRStudio: Ambiente di sviluppo integrato (IDE) per R\n\nAssegnazione\nR usato come un calcolatore\nEsecuzione di comandi in R\nTre modi per eseguire i comandi in R\n\nOggetti\nClassi di oggetti\n\nVettori\nFunzioni\nFunzione mean()\nFunzione length()\n\nData type di un vettore\nData type character\nData type logical\nI vettori sono omogenei\n\nSequenze\nAritmetica vettorializzata\nDati di tipo data.frame\nChe cosa c’è da capire su vettori e data.frame?\nSelezione di elementi\n\n\nSintassi\nÈ difficile sapere da dove iniziare quando si deve imparare un nuovo linguaggio di programmazione. Questi file Rmd hanno lo scopo di fornire qualche informazione di base che spero possa dare un’idea generale di come R viene usato.\nCi sono approcci diversi per imparare un linguaggio di programmazione come R. L’approccio meno efficiente è quello che ci porta a cercare le informazioni a proposito della sintassi di R quando ci servono per risolvere un problema specifico. Questo approccio è motivato dal fatto che non è molto divertente studiare la sintassi di un linguaggio di programmazione in termini astratti. Questo è l’approccio che seguo io. Per cui, secondo me, il modo migliore per imparare la sintassi di R è quello di… usare R e cercare con Google la soluzione di ciascuno specifico problema di sintassi, quando esso si presenta.\nL’approccio più tradizionale (e molto più efficiente) è invece quello di leggere un manuale in cui tutto viene presentato in maniera sistematica. È facilissimo trovare in rete un enorme numero di guide all’utilizzo dell’ambiente statistico R. Uno dei punti di entrata in questo mondo è sicuramente il testo scritto da Hadley Wickham: R for Data Science. Può anche essere utile e/o divertente leggere i messaggi twitter che utilizzano l’hashtag #rstats.\nR: linguaggio + ambiente\nR è un port al linguaggio S, sviluppata presso i Bell Labs. R è open source e gratuito da utilizzare e distribuire. Può essere installato e utilizzato sui principali sistemi operativi.\nR può essere inteso come un linguaggio e un ambiente integrati che sono stati progettati avendo come finalità il calcolo statistico e l’analisi dei dati. A tal fine, la sua struttura rappresenta un compromesso tra una base di codice he è stata ottimizzata per le procedure matematiche sopra la quale sono state sviluppate funzionalità di alto livello che possono essere utilizzate in modo interattivo. In altre parole, è un ottimo strumento per lavorare in modo interattivo con dati quantitativi.\nLe funzionalità di R si stanno estendendo sempre più attraverso pacchetti forniti dagli utenti. Useremo un certo numero di pacchetti in questo insegnamento, soprattutto quelli sviluppati all’interno della famiglia tidyverse.\nRStudio: Ambiente di sviluppo integrato (IDE) per R\nRStudio fa quasi tutto ciò che è può essere fatto con R, in maniera più semplice. Quindi è un ottimo programma completo per l’utilizzo di R. Lo consiglio vivamente.\nAssegnazione\nIn R, qualcunque cosa è un oggetto. Gli oggetti sono come scatole in cui possiamo mettere le cose: dati, funzioni e persino altri oggetti.\nPrima di discutere i tipi di dati e le strutture, il primo argomento che presenteremo relativamente alla sintassi di R è come assegnare valori agli oggetti. In R, il mezzo principale di assegnazione è la freccia, <-, che è un simbolo minore di <, seguito da un trattino, -.\n\n\nx <- 3\nx\n\n\n[1] 3\n\ne anche\n\n\ny <- \"estate\"\ny\n\n\n[1] \"estate\"\n\nR usato come un calcolatore\nR può essere usato come qualunque calcolatore portatile. Avendo a disposizione un computer è ridicolo usare un calcolatore portatile. All’esame, molti studenti si ostinano ad usare uno smartphone per fare i calcoli. Credetemi, è molto più facile fare i calcoli usando R su un computer!\nLe operazioni algebriche si svolgono nel modo seguente:\n\n\n5 + 2\n\n\n[1] 7\n\n7 - 3\n\n\n[1] 4\n\n10 * 3\n\n\n[1] 30\n\n21 / 3\n\n\n[1] 7\n\nx^2\n\n\n[1] 9\n\nsqrt(9)\n\n\n[1] 3\n\nEsecuzione di comandi in R\nTre modi per eseguire i comandi in R\nUsare la console.\nDigitare / copiare i comandi direttamente nella “console” (non una buona idea, a meno che facciamo qualcosa di estremamente semplice e non ci interessa salvare il procedimento).\nUsare uno script R (file .R).\nUno script R può essere creato in RStudio mediante il menu a tendina File > New File > R Script. Può essere salvato come un qualunque altro file e può essere riutilizzato e modificato in un secondo momento. È possibile eseguire un comando alla volta, più comandi alla volta o l’intero script. - Cmd / Ctrl + Invio: esegue le linee evidenziate - Cmd / Ctrl + Maiusc + Invio (senza evidenziare alcuna riga): esegue l’intero script.\nUsare un file RMarkdown (file .Rmd).\nI file RMarkdown possono essere creati in RStudio mediante il menu a tendina File > New File > R Notebook. Un file RMarkdown è costituito da diversi “code chunks”. È possibile eseguire un comando alla volta, un blocco alla volta o eseguire “knit” sull’intero documento. - Cmd / Ctrl + Invio: esegue le linee evidenziate all’interno del blocco - Cmd / Ctrl + Shift + k: “knit” per l’intero documento\nOggetti\nR è un linguaggio di programmazione “object-oriented” (come Python). Ma cos’è un “oggetto”?\nIntuitivamente, possiamo pensare che gli oggetti siano qualcosa a cui vengono assegnati dei valori.\n\n\na <- 5\na\n\n\n[1] 5\n\nb <- \"eilà!\"\nb\n\n\n[1] \"eilà!\"\n\n\nObjects are like boxes in which we can put things: data, functions, and even other objects.\n\nSi noti che per assegnare un numero all’oggetto a abbiamo digitato il numero a sinistra dell’operatore di assegnazione. Nel caso di una stringa, invece, è stato necessario scrivere la serie di simboli alfanumerici tra virgolette.\nNon c’è limite al numero di oggetti che R può contenere (tranne la memoria).\nClassi di oggetti\nGli oggetti possono essere categorizzati in base alle categorie “type” e “class”.\nAd esempio, una data è un oggetto con type numerico e una class “date”;\nun dataset è un oggetto con specifiche caratteristiche type e class.\nVettori\nL’oggetto fondamentale in R è il vettore\nUn vettore è un insieme di valori.\nI singoli valori all’interno di un vettore sono chiamati “elementi”.\nI valori in un vettore possono essere numerici o possono essere delle stringhe alfanumeriche (ad esempio “Pomodoro”) o appartenenti ad altre classi type.\nDi seguito utilizzeremo la funzione di concatenazione c() per creare un vettore.\nIl file di aiuto dice che la funzione c() “concatena i suoi argomenti in un vettore o in un elenco”.\n\n\n?c\n\n\n\nCreiamo ora un vettore in cui gli elementi sono dei numeri\n\n\nx <- c (4, 7, 9)\nx\n\n\n[1] 4 7 9\n\noppure un vettore in cui gli elementi sono delle stringhe\n\n\nanimali <- c(\"leoni\", \"tigri\", \"orsi\", \"Aaaargh!\")\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nFunzioni\nLe “funzioni” R applicano diversi tipi di trasformazioni a oggetti con diverse caratteristiche type e class.\nFunzione mean()\nAd esempio, la funzione mean() calcola la media per oggetti con type = numerico e class = vector; la funzione mean() non può essere applicata ad oggetti con type = character (ad es. “eilà!”).\n\n\nx\n\n\n[1] 4 7 9\n\nmean(x)\n\n\n[1] 6.666667\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nmean(animali)\n\n\n[1] NA\n\nFunzione length()\nLa funzione `length() ritorna il numero di elementi di un vettore.\n\n\nx\n\n\n[1] 4 7 9\n\nlength(x)\n\n\n[1] 3\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\nlength(animali)\n\n\n[1] 4\n\nUn singolo numero (o una singola stringa / carattere) è un vettore con length==1\n\n\nz <- 5\nlength(z)\n\n\n[1] 1\n\nlength(\"Maria\")\n\n\n[1] 1\n\nData type di un vettore\nIl “type” di un vettore descrive la classe a cui appartengono gli elementi del vettore. Si possono definire sei diversi “types” di elementi dei vettori, ma qui ne considereremo solo tre:\nnumeric:\n“integer” (e.g., 5)\n“double” (e.g., 5.5)\n\ncharacter (e.g., “ozan”)\nlogical (e.g., TRUE, FALSE)\nLa funzione typeof() viene usata per esaminare il “type” di un vettore:\n\n\nx\n\n\n[1] 4 7 9\n\ntypeof(x)\n\n\n[1] \"double\"\n\nanimali\n\n\n[1] \"leoni\"    \"tigri\"    \"orsi\"     \"Aaaargh!\"\n\ntypeof(animali)\n\n\n[1] \"character\"\n\nData type character\nA differenza dei tipi di dati “numeric” utilizzati per memorizzare i numeri, il tipo di dati “character” viene utilizzato per memorizzare stringhe di testo.\nLe stringhe possono contenere qualsiasi combinazione di numeri, lettere, simboli, ecc.\nI vettori di tipo “character” sono a volte indicati come vettori di tipo alfanumerico.\nQuando si crea un vettore in cui gli elementi hanno type == character (o quando si fa riferimento al valore di una stringa), si pongano le virgolette singole o doppie attorno al testo.\nIl testo tra virgolette è chiamato stringa.\n\n\nc1 <- c(\"cane\", 'felicità', 'cioccolata', 'tranquillità')\nc1\n\n\n[1] \"cane\"         \"felicità\"     \"cioccolata\"   \"tranquillità\"\n\ntypeof(c1)\n\n\n[1] \"character\"\n\nlength(c1)\n\n\n[1] 4\n\nI valori numerici possono anche essere memorizzati come stringhe\n\n\nc2 <- c(\"1\", \"2\", \"3\")\nc2\n\n\n[1] \"1\" \"2\" \"3\"\n\ntypeof(c2)\n\n\n[1] \"character\"\n\nIn tale caso però non possiamo applicare ad essi alcuna operazione aritmetica:\n\n\nmean(c2)\n\n\n[1] NA\n\nData type logical\nI vettori logici possono assumere tre possibili valori: TRUE, FALSE, NA.\nTRUE, FALSE, NA sono delle parole chiave; hanno un significato diverso dalle stringhe \"TRUE\", \"FALSE\", \"NA\"\nLa parola chiave NA viene utilizzata per codificare i dati mancanti.\n\n\ntypeof(TRUE)\n\n\n[1] \"logical\"\n\ntypeof(\"TRUE\")\n\n\n[1] \"character\"\n\ntypeof(c(TRUE,FALSE,NA))\n\n\n[1] \"logical\"\n\ntypeof(c(TRUE,FALSE,NA,\"FALSE\"))\n\n\n[1] \"character\"\n\nlog <- c(TRUE,TRUE,FALSE,NA,FALSE)\ntypeof(log)\n\n\n[1] \"logical\"\n\nlength(log)\n\n\n[1] 5\n\nI vettori sono omogenei\nTutti gli elementi di un vettore devono appartenere allo stesso tipo di dati.\nSe un vettore contiene elementi di diverso tipo, il vettore sarà della classe type dell’elemento più “complesso”,\nI tipi di vettori atomici, dal più semplice al più complesso, seguono la seguente gerarchia:\nlogical < integer < double < character\n\n\ntypeof(c(TRUE, TRUE, NA))\n\n\n[1] \"logical\"\n\ntypeof(c(TRUE, TRUE, NA, 1L)) \n\n\n[1] \"integer\"\n\ntypeof(c(TRUE, TRUE, NA, 1.5))\n\n\n[1] \"double\"\n\ntypeof(c(TRUE, TRUE, NA, 1.5, \"come va?\"))\n\n\n[1] \"character\"\n\nSequenze\nDefinizione: una sequenza è un insieme di numeri in ordine ascendente o discendente\nUn vettore contenente una “sequenza” di numeri (ad es. 1, 2, 3) può essere creato usando l’operatore : con la notazione start : end\n\n\n-5:5\n\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n5:-5\n\n\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\ns <- 1:10 \ns\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nlength(s)\n\n\n[1] 10\n\nSu possono creare sequenze usando la funzione seq():\n\n\nseq(from = 1, to = 1, by = 1)\n\n\n[1] 1\n\n\n\nseq(10, 15)\n\n\n[1] 10 11 12 13 14 15\n\nseq(from = 10, to = 15, by = 1)\n\n\n[1] 10 11 12 13 14 15\n\nseq(from = 100, to = 150, by = 10)\n\n\n[1] 100 110 120 130 140 150\n\nAritmetica vettorializzata\nLe operazioni aritmetiche sui vettori vengono applicate ``elemento per elemento’’.\nQuesto è un punto estremamente importante a cui è necessario prestare particolare attenzione.\nAd esempio, se un singolo valore viene sommato ad un vettore, tale valore verrà sommato a ciascun elemento del vettore:\n\n\n1:3\n\n\n[1] 1 2 3\n\n1:3 + 0.5\n\n\n[1] 1.5 2.5 3.5\n\n(1:3) * 2\n\n\n[1] 2 4 6\n\nAnche le operazioni aritmetiche che coinvolgono due vettori della stessa lunghezza vengono applicate ``elemento per elemento’’.\nPer la somma di due vettori, ad esempio, R esegue quanto segue: somma il primo elemento del vettore 1 al primo elemento del vettore 2; somma il secondo elemento del vettore 1 al secondo elemento del vettore 2; ecc.\nLo stesso vale per le altre operazioni algebriche sui vettori.\n\n\nc(1, 1, 1) + c(1, 0, -2)\n\n\n[1]  2  1 -1\n\nc(1, 1, 1) * c(1, 0, -2)\n\n\n[1]  1  0 -2\n\nDati di tipo data.frame\nLa matrice dei dati può essere codificata in R usando quella struttura di dati che va sotto il nome di data.frame.\nLa maggior parte delle volte i data.frame vengono importati da fonti esterne. Tuttavia, è anche possibile crearli direttamente in R. A questo fine usiamo la funzione data.frame():\n\n\ndf <- data.frame(\n  col_a = c(1, 2, 3, 4),\n  col_b = c(5, 6, 7, 8),\n  col_c = c(9, 10, 11, 12)\n)\n\n\n\nStampiamo il contenuto di df sulla console:\n\n\ndf\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\n\n\n## check\nis.data.frame(df)\n\n\n[1] TRUE\n\n\n\nhead(df) # stampa le prime 6 righe\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\nI data.frame possiedono vari attributi:\n\n\nnames(df)\n\n\n[1] \"col_a\" \"col_b\" \"col_c\"\n\ndim(df) \n\n\n[1] 4 3\n\nstr(df)\n\n\n'data.frame':   4 obs. of  3 variables:\n $ col_a: num  1 2 3 4\n $ col_b: num  5 6 7 8\n $ col_c: num  9 10 11 12\n\nLe colonne di un data.frame sono le variabili;\nLe variabili sono vettori.\nCiascuna riga del data.frame corrisponde ad un’osservazione (per esempio, un soggetto).\nEstraiamo da df la variabile col_a:\n\n\ndf$col_a\n\n\n[1] 1 2 3 4\n\nEsaminiamo la variabile col_a con più attenzione:\n\n\nlength(df$col_a) # length=numbero di righe/osservazioni\n\n\n[1] 4\n\nstr(df$col_a)\n\n\n num [1:4] 1 2 3 4\n\nChe cosa c’è da capire su vettori e data.frame?\nStruttura di base\nVettori: sono oggetti di type logical, integer, double, character.\ngli elementi di un vettore devono tutti appartere alla stessa classe type.\n\ndata.frame: sono collezioni di oggetti.\nGli elementi di un data.frame possono avere classi diverse tra loro (es., vettori numerici e vettori i cui elementi sono alfanumerici).\n\nBuona pratica: eseguire semplici diagnostiche su qualsiasi nuovo oggetto:\nlength() : quanti elementi ci sono in nell’oggetto?\ntypeof() : a che type di dati appatiene l’oggetto?\nstr() : mostra la struttura gerarchica dell’oggetto.\n\nSelezione di elementi\nR dispone di un sistema di notazione che consente di estrarre singoli elementi dagli oggetti. Per estrarre un valore da un data.frame, per esempio, dobbiamo scrivere il nome del data.frame seguito da una coppia di parentesi quadre:\n\ndf[ , ]\n\nAll’interno delle parentesi quadre ci sono due indici separati da una virgola. R usa il primo indice per selezionare un sottoinsieme di righe del data.frame e il secondo indice per selezionare un sottoinsieme di colonne. Ad esempio:\n\n\ndf\n\n\n  col_a col_b col_c\n1     1     5     9\n2     2     6    10\n3     3     7    11\n4     4     8    12\n\ndf[1, 1]\n\n\n[1] 1\n\ndf[, 1]\n\n\n[1] 1 2 3 4\n\ndf[2, ]\n\n\n  col_a col_b col_c\n2     2     6    10\n\ndf[1:2, 3]\n\n\n[1]  9 10\n\nPer estrarre un’intera colonna, è anche possibile usare l’operatore $ mediante la sintassi descritta in precedenza. Possiamo anche estrarre più di una colonna alla volta:\n\n\ndf[, c(\"col_b\", \"col_c\")]\n\n\n  col_b col_c\n1     5     9\n2     6    10\n3     7    11\n4     8    12\n\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.22 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": "posts/2021-03-08-introduzione-a-r-1/preview.png",
    "last_modified": "2021-03-20T11:40:12+01:00",
    "input_file": {},
    "preview_width": 954,
    "preview_height": 1428
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-2/",
    "title": "Introduzione a R (2)",
    "description": "Il secondo post sulla sintassi di base di R.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nFunzioni\nR offre la possibilità di utilizzare molteplici funzioni che permettono di svolgere svariate operazioni, più o meno complicate.\nSintassi di base\nPer esempio lancio di un dado può essere simulato da R con la funzione sample(). La funzione sample() prende due argomenti, il nome di un vettore e un numero chiamato size.\nLa funzione sample() ritorna un numero di elementi del vettore pari a size:\n\n\n# definiamo i valori che possono essere ottenuti dal lancio di un dado\ndie <- 1:6\ndie\n\n\n[1] 1 2 3 4 5 6\n\n# simuliamo il lancio di due dadi (o di due lanci di un dado)\nsample(die, 2)\n\n\n[1] 2 3\n\nCome si fa a sapere quanti e quali argomenti sono richiesti da una funzione? Tale informazione viene fornita dalla funzione args(). Per esempio,\n\n\nargs(sample)\n\n\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n\nci informa che il primo argomento della funzione sample() è un vettore chiamato x, il secondo argomento è chiamato size ed ha il significato descritto sopra, il terzo argomento, replace, specifica se il campionamento è eseguito con o senza reimmissione, e il quarto argomento, prob, assegna delle probabilità agli elementi del vettore.\nSi noti che gli argomenti sono contenuti all’interno di parentesi tonde.\nIl significato degli argomenti viene spiegato nel file di help della funzione. Si noti che agli ultimi due argomenti sono stati assegnati dei valori, detti di default. Ciò significa che, se l’utilizzatore non li cambia, verranno usati da R. replace = FALSE significa che il campionamento viene eseguito senza reimmissione. Se desideriamo un campionamento con reimmissione, basta specificare replace = TRUE (nel caso di una singola estrazione è ovviamente irrilevante). Ad esempio, l’istruzione seguente simula i risultati di 10 lanci indipendenti di un dado:\n\n\nsample(die, 10, replace = TRUE)\n\n\n [1] 4 3 1 6 4 2 5 5 5 5\n\nLo stesso risultato può essere ottenuto in lanci diversi. Infine, prob = NULL specifica che non viene alterata la probabilità di estrazione degli elementi del vettore. Manipolando questo argomento è possibile simulare i risultati di un dado ``truccato’’, ovvero nel quale i numeri hanno probabilità diversa di essere osservati.\nIn generale, gli argomenti di una funzione, possono essere oggetti come vettori, matrici, altre funzioni, parametri o operatori logici.\nScrivere proprie funzioni\nAbbiamo visto in precedenza come sia possibile simulare il risultati prodotti dai lanci di due dadi. Possiamo replicare questo processo digitando ripetutamente le stesse istruzioni nella console. Otterremo ogni volta risultati diversi perché, ad ogni ripetizione, il generatore di numeri pseudo-casuali di R dipende dal valore ottenuto dal clock interno della macchina. Tuttavia, questa procedura è praticamente difficile da perseguire se il numero di ripetizioni è alto. In tal caso è vantaggioso scrivere una funzione contenente il codice che specifica il numero di ripetizioni. In questo modo, per trovare il risultato cercato basterà chiamare la funzione una sola volta.\nLe funzioni di R sono costituite da tre elementi: il nome, il blocco del codice e una serie di argomenti. Per creare una funzione è necessario immagazzinare in R questi tre elementi e function() consente di ottenere tale risultato usando la sintassi seguente:\n\n\nnome_funzione <- function(arg1, arg2, ...) {\n  espressione1\n  espressione2\n  return(risultato)\n}\n\n\n\nLa formattazione del codice mediante l’uso di spazi e rientri non è necessaria ma è altamente raccomandata per minimizzare la probabilità di compiere errori.\nUna chiamata di funzione è poi eseguita nel seguente modo:\n\n\nnome_funzione(arg1, arg2, ...)\n\n\n\nPer potere essere utilizzata, una funzione deve essere presente nella memoria di lavoro di R. Le funzioni salvate in un file possono essere richiamate utilizzando la funzione source(), ad esempio,\n\n\nsource(\"file_funzioni.R\")\n\n\n\nConsideriamo ora la funzione che ritorna la somma dei punti prodotti dal lancio di due dadi onesti:\n\n\nroll <- function () {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE) \n  return(sum(dice))\n}\n\n\n\nLa funzione roll() crea il vettore die che contiene sei elementi: i numeri da 1 a 6. La funzione sample() con l’argomento replace = TRUE e l’argomento size = 2 trova i numeri usciti dal lancio di due dadi. Tramite l’operatore di attribuzione questi due numeri sono immagazzinati nel vettore dice. La funzione sum() somma i gli elementi del vettore dice. Infine, la funzione return() (opzionale) ritorna il risultato trovato.\nInvocando la funzione roll() si ottiene dunque un punteggio che è uguale alla somma dei valori dei due dadi lanciati. In generale, si trova un risultato diverso ogni volta che la funzione viene usata. La funzione set.seed() ci permette di replicare esattamente i risultati della generazione di numeri casuali. Per ottenere questo risultato, basta assegnare al seed un numero arbitrario:\n\n\nset.seed(12345)\nroll()\n\n\n[1] 9\n\nPacchetti\nLe funzioni di R sono organizzate in pacchetti, i più importanti dei quali sono già disponibili quando si accede al programma.\nIstallazione e upgrade dei pacchetti\nAlcuni pacchetti non sono presenti nella release di base di R. Per installare un pacchetto non presente è sufficiente scrivere nella console:\n\n\ninstall.packages(\"nome_pacchetto\") \n\n\n\nAd esempio,\n\n\ninstall.packages(\"ggplot2\") \n\n\n\nLa prima volta che si usa questa funzione durante una sessione di lavoro si dovrà anche selezionare da una lista il sito mirror da cui scaricare il pacchetto. Il R Core Development Team lavora continuamente per migliorare le prestazioni di R, per correggere errori e per consentire l’uso di R con nuove tecnologie. Di conseguenza, periodicamente vengono rilasciate nuove versioni di R. Informazioni a questo proposito sono fornite sulla pagina web https://www.r-project.org/. Per installare una nuova versione di R si segue la stessa procedura che si è seguita per installare la versione corrente. Anche gli autori dei pacchetti periodicamente rilasciano nuove versioni dei loro pacchetti che contengono miglioramenti di varia natura. Per eseguire l’upgrade dei pacchetti ggplot2 e dplyr, ad esempio, si usa la seguente istruzione:\n\n\nupdate.packages(c(\"ggplot2\", \"dplyr\"))\n\n\n\nPer eseguire l’upgrade di tutti i pacchetti l’istruzione è\n\n\nupdate.packages()\n\n\n\nCaricare un pacchetto in R\nL’istallazione dei pacchetti non rende immediatamente disponibili le funzioni in essi contenute. L’istallazione di un pacchetto semplicemente copia il codice sul disco rigido della macchina in uso. Per potere usare le funzioni contenute in un pacchetto installato è necessario caricare il pacchetto in R. Ciò si ottiene con il comando:\n\n\nlibrary(\"ggplot2\")\n\n\n\nse si vuole caricare il pacchetto ggplot2. A questo punto diventa possibile usare le funzioni contenute in ggplot2.\nPer sapere quali sono i pacchetti già presenti nella release di R con cui si sta lavorando, basta digitare:\n\n\nsessionInfo()\n\n\nR version 3.6.3 (2020-02-29)\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\nRunning under: macOS Mojave 10.14.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nloaded via a namespace (and not attached):\n [1] fansi_0.4.2          digest_0.6.27        R6_2.5.0            \n [4] jsonlite_1.7.2       magrittr_2.0.1       evaluate_0.14       \n [7] stringi_1.5.3        rlang_0.4.10         jquerylib_0.1.3     \n[10] bslib_0.2.4          vctrs_0.3.6          rmarkdown_2.7.3     \n[13] distill_1.2          tools_3.6.3          stringr_1.4.0       \n[16] xfun_0.21            yaml_2.2.1           compiler_3.6.3      \n[19] htmltools_0.5.1.9000 knitr_1.31           downlit_0.2.1       \n[22] sass_0.3.1          \n\nGiocare a poker con R\nPer fare un esempio che ci consenta di applicare le nozioni discusse in precedenza ad una situazione concreta, consideriamo il gioco del poker.\nDefiniamo un data.frame che codifica le carte di un mazzo di 52 carte:\n\n\ndeck <- data.frame(\n  face = c(\n  \"king\", \"queen\", \"jack\", \"ten\", \" nine\", \"eight\",\"seven\", \"six\", \n  \"five\", \"four\", \"three\", \"two \", \"ace\", \"king\", \"queen\", \"jack\", \n  \"ten\", \"nine\", \"eight\", \" seven\", \"six\", \"five\", \"four\", \"three\", \n  \"two\", \"ace\", \"king\" , \"queen\", \"jack\", \"ten\", \"nine\", \"eight\", \n  \"seven\", \"six\", \" five\", \"four\", \"three\", \"two\", \"ace\", \"king\", \n  \"queen\", \"jack \", \"ten\", \"nine\", \"eight\", \"seven\", \"six\", \"five\", \n  \"four\", \" three\", \"two\", \"ace\"\n  ), \n  suit = c(\n    \"spades\", \"spades\", \"spades\" , \"spades\", \"spades\", \"spades\", \n    \"spades\", \"spades\", \"spades\" , \"spades\", \"spades\", \"spades\", \n    \"spades\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\", \"clubs\",\n    \"clubs\", \"clubs\", \"clubs \", \"clubs\", \"clubs\", \"clubs\", \"clubs\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"diamonds\", \"diamonds\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"diamonds\", \"diamonds\",\n    \"diamonds\", \"diamonds \", \"diamonds\", \"hearts\", \"hearts\", \n    \"hearts\", \"hearts\", \" hearts\", \"hearts\", \"hearts\", \"hearts\", \n    \"hearts\", \"hearts\", \" hearts\", \"hearts\", \"hearts\"\n  ), \n  value = c(\n    13, 12, 11, 10, 9, 8 , 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, \n    9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, \n    3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n  )\n)\n\n\n\nCosì facendo abbiamo ottenuto il seguente risultato:\n\n\ndeck\n\n\n     face      suit value\n1    king    spades    13\n2   queen    spades    12\n3    jack    spades    11\n4     ten    spades    10\n5    nine    spades     9\n6   eight    spades     8\n7   seven    spades     7\n8     six    spades     6\n9    five    spades     5\n10   four    spades     4\n11  three    spades     3\n12   two     spades     2\n13    ace    spades     1\n14   king     clubs    13\n15  queen     clubs    12\n16   jack     clubs    11\n17    ten     clubs    10\n18   nine     clubs     9\n19  eight     clubs     8\n20  seven     clubs     7\n21    six     clubs     6\n22   five    clubs      5\n23   four     clubs     4\n24  three     clubs     3\n25    two     clubs     2\n26    ace     clubs     1\n27   king  diamonds    13\n28  queen diamonds     12\n29   jack  diamonds    11\n30    ten  diamonds    10\n31   nine  diamonds     9\n32  eight  diamonds     8\n33  seven diamonds      7\n34    six  diamonds     6\n35   five  diamonds     5\n36   four  diamonds     4\n37  three  diamonds     3\n38    two diamonds      2\n39    ace  diamonds     1\n40   king    hearts    13\n41  queen    hearts    12\n42  jack     hearts    11\n43    ten    hearts    10\n44   nine    hearts     9\n45  eight    hearts     8\n46  seven    hearts     7\n47    six    hearts     6\n48   five    hearts     5\n49   four    hearts     4\n50  three    hearts     3\n51    two    hearts     2\n52    ace    hearts     1\n\nPoniamoci il problema di mescolare il mazzo di carte e di estrarre a caso alcune carte dal mazzo.\nL’istruzione\n\n\ndeck[1:52, ]\n\n\n     face      suit value\n1    king    spades    13\n2   queen    spades    12\n3    jack    spades    11\n4     ten    spades    10\n5    nine    spades     9\n6   eight    spades     8\n7   seven    spades     7\n8     six    spades     6\n9    five    spades     5\n10   four    spades     4\n11  three    spades     3\n12   two     spades     2\n13    ace    spades     1\n14   king     clubs    13\n15  queen     clubs    12\n16   jack     clubs    11\n17    ten     clubs    10\n18   nine     clubs     9\n19  eight     clubs     8\n20  seven     clubs     7\n21    six     clubs     6\n22   five    clubs      5\n23   four     clubs     4\n24  three     clubs     3\n25    two     clubs     2\n26    ace     clubs     1\n27   king  diamonds    13\n28  queen diamonds     12\n29   jack  diamonds    11\n30    ten  diamonds    10\n31   nine  diamonds     9\n32  eight  diamonds     8\n33  seven diamonds      7\n34    six  diamonds     6\n35   five  diamonds     5\n36   four  diamonds     4\n37  three  diamonds     3\n38    two diamonds      2\n39    ace  diamonds     1\n40   king    hearts    13\n41  queen    hearts    12\n42  jack     hearts    11\n43    ten    hearts    10\n44   nine    hearts     9\n45  eight    hearts     8\n46  seven    hearts     7\n47    six    hearts     6\n48   five    hearts     5\n49   four    hearts     4\n50  three    hearts     3\n51    two    hearts     2\n52    ace    hearts     1\n\nritorna tutte le righe e tutte e le colonne del data.frame deck. Le righe sono identificate dal primo indice che, nel caso presente, va da 1 a 52.\nPermutare in modo casuale l’indice delle righe equivale a mescolare il mazzo di carte. Per fare questo, utilizziamo la funzione sample() ponendo replace=FALSE e size uguale alla dimensione del vettore che contiene gli indici da 1 a 52:\n\n\nrandom <-\n  sample(\n    1:52,\n    size = 52, \n    replace = FALSE\n  )\nrandom\n\n\n [1] 16 26 28 24 29 11 32 49  2 22 47 38 39 30 10 17 46 40  1 12 20  8\n[23] 51 33  3  9 14 13 36 41 52 43 44 27  4 31 42  6 19  5 50 34 21 25\n[45] 45 37 48 15 23 35 18  7\n\nUtilizzando ora il vettore random di indici permutati otteniamo il risultato cercato:\n\n\ndeck_shuffled <- deck[random, ] \nhead(deck_shuffled)\n\n\n    face      suit value\n16  jack     clubs    11\n26   ace     clubs     1\n28 queen diamonds     12\n24 three     clubs     3\n29  jack  diamonds    11\n11 three    spades     3\n\nPossiamo ora scrivere una funzione che include le istruzioni precedenti:\n\n\nshuffle <- function(cards) {\n  random <- sample(1:52, size = 52, replace = FALSE)\n  return(cards[random, ])\n}\n\n\n\nInvocando la funzione shuffle() possiamo dunque generare un data.frame che rappresenta un mazzo di carte mescolato:\n\n\ndeck_shuffled <- shuffle(deck)\n\n\n\nSe immaginiamo di distribuire le carte di questo mazzo a due giocatori di poker, per il primo giocatore avremo:\n\n\ndeck_shuffled[c(1, 3, 5, 7, 9), ]\n\n\n    face     suit value\n10  four   spades     4\n27  king diamonds    13\n44  nine   hearts     9\n45 eight   hearts     8\n42 jack    hearts    11\n\ne per il secondo:\n\n\ndeck_shuffled[c(2, 4, 6, 8, 10), ]\n\n\n    face     suit value\n43   ten   hearts    10\n34   six diamonds     6\n35  five diamonds     5\n22  five   clubs      5\n23  four    clubs     4\n\nEsercizi\n1. Sia x = c(2, 1, 6, 4). Si calcoli la media di x.\nSi trovi la soluzione utilizzando le semplici operazioni algebriche di somma e divisione, specificando l’ordine corretto con il quale vengono eseguite le operazioni mediante le partentesi tonde.\nLa funzione mean() ritorna la media di un vettore. Si trovi la soluzione utilizzando la funzione mean().\nSi trovi la soluzione utilizzando le funzioni base di R, quando viene implementata la formula \\(\\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i\\). Per applicare questa formula, possiamo utilizzare le seguenti ulteriori funzioni R:\nlength(), la quale ritorna il numero degli elementi del vettore che viene passato come argomento alla funzione;\nsum(), la quale ritorna la somma degli elementi del vettore che viene passato come argomento alla funzione.\n2. Sia x = c(2, 1, 6, 4). Si scriva una funzione che calcola la media di x divisa per valore massimo di x. Si trovi il risultato cercato utilizzando la funzione così definita. In R, le funzioni min() e max() ritornano il minimo e il massimo del vettore che viene passato come argomento.\n3. Sia x = c(2, 1, 6, 4). Si verifichi che la somma degli scarti degli elementi del vettore x dalla media \\(\\bar{x}\\) è uguale a zero. [Suggerimento: si trovi il vettore di scargi di ciascun elemento x da \\(\\bar{x}\\). Si sommino gli elementi del vettore che contiene gli scarti dalla media.]\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.21 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T08:43:42+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-3/",
    "title": "Introduzione a R (3)",
    "description": "Il terzo post sulla sintassi di base di R: strutture di controllo.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nIn R esistono strutture di controllo specifiche per regolare il flusso di esecuzione di un programma. Le istruzioni di controllo if … else consentono di selezionare tra diversi blocchi di codice. I loop permettono di ripetere ciclicamente blocchi di istruzioni per un numero prefissato di volte o fino a che una determinata condizione logica viene soddisfatta. Questo li rende utili per la programmazione di simulazioni numeriche.\nBlocchi di istruzioni\nUn blocco di istruzioni è formato da tutte le linee di programma che sono comprese entro una coppia di parentesi graffe, apera e chiusa. La formazione di un blocco serve principalmente per isolare un gruppo di istruzioni che costituiscono una parte ben definita di programma. La struttura generale di un blocco è la seguente:\n\n\n{\n  istruzioni\n}\n\n\n\nEsecuzione selettiva di blocchi\nÈ frequente scrivere programmi che eseguono azioni diverse in corrispondenza di condizioni diverse – il caso più ovvio è il valore di una particolare variabile. Situazioni del genere possono ben essere gestite mediante una successione di istruzioni if … else if … else.\nIn R l’istruzione condizionale if possiede la seguente sintassi:\n\nif (espressione) \n  istruzioni da eseguire se la espressione == TRUE\n\nAd esempio\n\n\nx <- 30\nif (x > 18) \n  print(\"il voto è sufficiente\")\n\n\n[1] \"il voto è sufficiente\"\n\n\n\nx <- 17\nif (x > 18) \n  print(\"il voto è sufficiente\")\n\n\n\nIn questo secondo caso, la condizione non è soddisfatta quindi non viene stampato nulla.\nCi possono però essere molteplici condizioni da valutare. Per fare questo usiamo la sintassi if () else if () else:\n\nif (espressione1) {\n  istruzioni da eseguire se la espressione1 == TRUE\n}\nelse if (espressione2) {\n  istruzioni da eseguire se la espressione2 == TRUE\n} else {\n  istruzioni da eseguire se nessuna delle espressioni è verificata\n}\n\nAd esempio,\n\n\ntemp_eval <- function(x) {\n  if (x > 40) {\n    \"è troppo caldo\"\n  } else if (x > 30) {\n    \"è molto caldo\"\n  } else if (x > 20) {\n    \"ottimo!\"\n  } else {\n    \"fa troppo freddo\"\n  }\n}\n\ntemp_eval(15)\n\n\n[1] \"fa troppo freddo\"\n\nFunzione if vettorializzata\nLa funzione if può essere applicata ad una sola condizione TRUE o FALSE. Che fare quando abbiamo a disposizione un vettore di valori logici? Di questo si occupa la funzione ifelse. Tale funzione prende tre argomenti: il primo argomento è una condizione da valutare; il secondo argomento è l’output se la condizione è vera; il terzo argomento specifica l’output se la condizione è fals. Se ad ifelse viene passato un vettore, allora la condizione del specificata dal primo argomento viene valutata per ciascun elemento del vettore. Si avrà in output un vettore della stessa lughezza di quello in input; ogni elemento di tale vettore sarà dato dalla scelta fatta da ifelse tra il secondo e terzo argomento, a seconda che l’espressione specificata nel primo argomento sia o meno verificata.\nPer esempio\n\n\nx <- 1:10\nifelse(x <= 5, \"valore piccolo\", \"valore grande\")\n\n\n [1] \"valore piccolo\" \"valore piccolo\" \"valore piccolo\"\n [4] \"valore piccolo\" \"valore piccolo\" \"valore grande\" \n [7] \"valore grande\"  \"valore grande\"  \"valore grande\" \n[10] \"valore grande\" \n\nIl ciclo for\nIl ciclo for è una struttura di controllo iterativa che opera sugli elementi di un vettore. Ha la seguente struttura di base:\n\n\nfor (indice in vettore) { \n  esegui_azione \n}\n\n\n\novvero, esegui_azione viene eseguito una volta per ciascun elemento di vettore, incrementando il valore di indice dopo ciascuna iterazione.\nPer esempio, il seguente ciclo for non fa altro che stampare il valore della variabile contatore i in ciascuna esecuzione del ciclo:\n\n\nfor (i in 1:3) { \n  print(i)\n}\n\n\n[1] 1\n[1] 2\n[1] 3\n\nUn esempio (leggermente) più complicato è il seguente:\n\n\nx <- seq(1, 9, by = 2) \nx\n\n\n[1] 1 3 5 7 9\n\nsum_x <- 0\nfor (i in seq_along(x)) {\n  sum_x <- sum_x + x[i]\n  cat(\"L'indice corrente e'\", i, \"\\n\")\n  cat(\"La frequenza cumulata e'\", sum_x, \"\\n\")\n}\n\n\nL'indice corrente e' 1 \nLa frequenza cumulata e' 1 \nL'indice corrente e' 2 \nLa frequenza cumulata e' 4 \nL'indice corrente e' 3 \nLa frequenza cumulata e' 9 \nL'indice corrente e' 4 \nLa frequenza cumulata e' 16 \nL'indice corrente e' 5 \nLa frequenza cumulata e' 25 \n\nUn esempio più complicato è il seguente. Chiadiamoci quanti numeri pari sono contenuti in un vettore. Per rispondere a questa domanda scriviamo la funzione count_even_numbers():\n\n\ncount_even_numbers <- function(x) {\n  count <- 0\n  for (i in seq_along(x)) {\n    if (x[i] %% 2 == 0) \n      count <- count + 1\n  }\n  count\n}\n\n\n\nNella funzione count_even_numbers() abbiamo inizializzato la variabile count a zero. Prima dell’esecuzione del ciclo for, dunque, count vale zero. Il ciclo for viene eseguito tante volte quanti sono gli elementi che costituiscono il vettore x. L’indice i dunque assume valori compresi tra 1 e il valore che corrisponde al numero di elementi di x. Infatti\n\n\nx\n\n\n[1] 1 3 5 7 9\n\nseq_along(x)\n\n\n[1] 1 2 3 4 5\n\nL’operazione modulo, indicato con %% dà come risultato il resto della divisione euclidea del primo numero per il secondo. Intuitivamente, la divisione euclidea è quell’operazione che si fa quando si suddivide un numero a di oggetti in gruppi di b oggetti ciascuno e si conta quanti gruppi sono stati formati e quanti oggetti sono rimasti. Per esempio, 9 %% 2 dà come risultato 1 perché questo è il resto della divisione [9/2] = 4, quindi 9 - (2 * 4) = 1 e dunque il resto è 1. L’operazione modulo dà come risultato 0 per tutti i numeri pari.\nIn ciascuna esecuzione del ciclo for l’operazione modulo viene eseguita, successivamente, su uno degli elementi di x. Se l’operazione modulo dà 0 come risultato, ovvero se il valore considerato è un numero pari, allora la variabile count viene incrementata di un’unità.\nL’ultima istruzione prima della parentesi graffa chiusa riporta ciò che viene ritornato dalla funzione.\nPer esempio:\n\n\ncount_even_numbers(x)\n\n\n[1] 0\n\n\n\ncount_even_numbers(c(x, 24))\n\n\n[1] 1\n\n\n\ncount_even_numbers(c(2, 4, 6, 8))\n\n\n[1] 4\n\nSimulazione del gioco d’azzardo Sopra-Sotto 7\nNel gioco d’azzardo con due dadi Sopra-Sotto 7 (Under-Over 7) vengono accettati tre tipi di scommesse:\nuna scommessa alla pari che il totale sarà inferiore a 7;\nuna scommessa alla pari che il totale sarà superiore a 7;\nuna scommessa che il totale sarà proprio 7, pagata 4 a 1.\nPoniamoci il problema di valutare se è conveniente la scommessa che il totale sarà 7 (vedremo in seguito come sia possibile risolvere questo problema in maniera formale, senza eseguire una simulazione). Iniziamo con il definire il vettore die che contiene ciascuno dei risultati possibili del lancio di un dado:\n\n\ndie <- c(1, 2, 3, 4, 5, 6) \ndie\n\n\n[1] 1 2 3 4 5 6\n\nLa funzione expand.grid() elenca tutte le possibili combinazioni degli elementi di 𝑛 vettori. Con essa possiamo dunque creare tutte le possibili combinazioni possibili con due dadi: dato che ogni dado ha sei facce, le combinazioni possibili sono 6 × 6 = 36:\n\n\nrolls <- expand.grid(die, die) \nrolls\n\n\n   Var1 Var2\n1     1    1\n2     2    1\n3     3    1\n4     4    1\n5     5    1\n6     6    1\n7     1    2\n8     2    2\n9     3    2\n10    4    2\n11    5    2\n12    6    2\n13    1    3\n14    2    3\n15    3    3\n16    4    3\n17    5    3\n18    6    3\n19    1    4\n20    2    4\n21    3    4\n22    4    4\n23    5    4\n24    6    4\n25    1    5\n26    2    5\n27    3    5\n28    4    5\n29    5    5\n30    6    5\n31    1    6\n32    2    6\n33    3    6\n34    4    6\n35    5    6\n36    6    6\n\nLa funzione expand.grid() può anche essere usata con più di due vettori; per esempio, potremmo usarla per elencare tutte le possibili combinazioni possibili con tre dadi, quattro dadi, ecc.\nCalcoliamo ora la somma dei due lanci. Per fare questo sommiamo due vettori, dato che la somma di vettori viene eseguita in R elemento per elemento:\n\n\nrolls$value <- rolls$Var1 + rolls$Var2 \nhead(rolls, n = 3)\n\n\n  Var1 Var2 value\n1    1    1     2\n2    2    1     3\n3    3    1     4\n\nLa somma è contenuta nella colonna value del data.frame rolls. Passiamo ora il data.frame rolls alla funzione roll_dice(). Questa fun- zione sceglie una riga a caso del data.frame e valuta il valore della variabile value. Se value (la somma dei due lanci) è uguale a 7, la funzione ritorna una vincita di 4; altrimenti ritorna una vincita di 0.\n\n\nroll_dice <- function(df) {\n  random <- sample(1:nrow(df), size = 1)\n  if (df[random, 3] == 7) {\n    return(4)\n  } else {\n    return(0)\n  }\n}\n\n\n\nSi noti che il valore del data.frame all’intero della funzione roll_dice è df, mentre, quando invochiamo la funzione usiamo come argomento di roll_dice l’oggetto rolls. Questo succede perché, quando eseguiamo l’istruzione roll_dice(rolls), comunichiamo ad R che vogliamo che venga eseguita la funzione roll_dice() e che passiamo alla funzione l’oggetto rolls. L’oggetto rolls è l’argomento che passiamo alla funzione roll_dice(). La funzione è stata definita in modo tale che il suo argomento, localmente, si chiama df. All’interno della funzione, dunque, le operazioni sull’argomento che è stato passato alla funzione verranno eseguite sull’oggetto df.\nQuesto significha, in generale, che gli oggetti che vengono manipolati all’interno di una funzione hanno un’esistenza locale, ovvero, non esistono al di fuori della funzione. Si dice: What Happens in Vegas, stays in Vegas. Lo stesso vale per le funzioni: qualsiasi cosa succeda dentro ad una funzione, fuori non si vede.\nUsiamo ora un ciclo for per ripetere 100,000 volte una scommessa unitaria.\n\n\nn_bets <- 1e5\noutcome <- rep(NA, n_bets)\nfor (i in 1:n_bets) {\n  outcome[i] <- roll_dice(rolls)\n}\n\n\n\nLo scalare n_bets specifica il numero di ripetizioni del ciclo for. L’istruzione\n\n\noutcome <- rep(NA, n_bets)\n\n\n\ncrea un vettore vuoto, chiamato outcome, dove verranno salvati i risultati calcolati ad ogni esecuzione del ciclo. Si noti l’utilizzo delle parentesi quadre. L’istruzione [i] significa che facciamo riferimento all’elemento i-esimo di outcome. La prima volta che si entra nel ciclo, il contatore ì vale 1. Dunque, la vincita della prima scommessa sarà salvata nel primo elemento del vettore outcome. Eseguite tutte le istruzioni contenute nel blocco del ciclo, il contatore assume il valore 2 e le istruzioni contenute nel corpo del ciclo vengono eseguite una seconda volta.\nLa funzione roll_dice() ritornerà la vincita (in generale, diversa da quella precedente) per una seconda scommessa e questo risultato verrà salvato nel secondo elemento del vettore outcome. Questo processo viene ripetuto n_bets volte. Il fatto che la variabile contatore assuma il valore finale previsto (nel nostro caso n_bets = 100000) è la condizione che fa terminare il ciclo.\nUna volta completata l’esecuzione del ciclo, il vettore outcome conterrà le medie di 100000 scommesse. La media di questi 100,000 numeri è quello che ci possiamo aspettare di guadagnare, o di perdere, per ogni scommessa unitaria. Se tale valore è uguale a 1, questo vuol dire che, a lungo andare, ci aspettiamo né di vincere né di perdere, ma di ricevere una somma uguale alla posta versata. Se tale valore è minore di 1 ci aspettiamo a lungo andare di perdere una proporzione della posta versata pari a 1 meno il valore trovato dalla simulazione. Se tale valore è maggiore di 1 ci aspettiamo a lungo andare di vincere una proporzione della posta versata pari al valore trovato dalla simulazione meno 1. Nel caso presente, il risultato della simulazione è 0.669 (contro un risultato teorico di 0.667). Ciò significa che, puntando 100 euro, a lungo andare ci aspettiamo di perdere 33.1 euro.\nEsercizi\n1. Utilizzando un ciclo for, si stampi il valore del contatore del ciclo, quando il ciclo for viene eseguito 10 volte. Si usi la funzione print() per stampare il risultato desiderato in ciscuna iterazione.\n2. Sia x = c(3, 1, 7, 9). Utilizzando un ciclo for, si crei un nuovo vettore y i cui elementi hanno un valore doppio rispetto a x.\n3. Si usi un ciclo for per stampare, ad ogni iterazione, il numero 1 un numero di volte uguale al contatore del ciclo. Per esempio, la terza volta che il ciclo viene eseguito va stampata la sequenza 1 1 1.\n\n\n\n4. Si carichi il data.frame iris fornito da R. Si trovi il numero di elementi distinti in ciascuna colonna del data.frame. Per trovare la soluzione si utilizzi un ciclo for. La soluzione è riportata qui sotto.\n[Suggerimento. I data.frame forniti da R si leggono nel workspace mediante la funzione data(). Per risolvere il problema dobbiamo prima definire un vettore vuoto dove salveremo i risultati. Poi dobbiamo trovare il modo per fare riferimento a ciascuna colonna del data.frame all’interno del ciclo for. Un modo per fare questo è di fare riferimento a ciascuna colonna i-esima del data.frame df con la sintassi df[[i]]. Infine, dobbiamo trovare un modo per contare il numero di elementi distinti di un vettore. La funzione unique() fa proprio questo.\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n          35           23           43           22            3 \n\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nloaded via a namespace (and not attached): [1] fansi_0.4.2 digest_0.6.27 R6_2.5.0\n[4] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14\n[7] stringi_1.5.3 rlang_0.4.10 jquerylib_0.1.3\n[10] bslib_0.2.4 vctrs_0.3.6 rmarkdown_2.7.3\n[13] distill_1.2 tools_3.6.3 stringr_1.4.0\n[16] xfun_0.21 yaml_2.2.1 compiler_3.6.3\n[19] htmltools_0.5.1.9000 knitr_1.31 downlit_0.2.1\n[22] sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T12:09:48+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-4/",
    "title": "Introduzione a R (4)",
    "description": "Il quarto post sulla sintassi di base di R: input/output.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nLeggere i dati\nCaricare i dati in R è una delle cose più importanti che si devono fare. Se non puoi importare i dati in R, allora non importa quali trucchetti potresti avere imparato: nulla può essere fatto. Importare i dati è anche una delle cose più frustranti - non solo in R, ma in generale. Se sei fortunato, i dati che stai cercando di caricare in R sono stati salvati come file .csv. L’estensione .csv sta per “Valori separati da virgola” e significa che i dati sono memorizzati in righe con virgole che separano le variabili. In questo caso, è facile importare i dati in R.\nOra, anche se sei fortunato e i tuoi dati sono in formato .csv, se sei un novizio del computer, allora avrai ancora qualche frustrazione nell’importare il file in R. Infatti, è necessario comunicare ad R dove sul computer è stato salvato il file da importare.\nÈ possibile risolvere tale problema specificando il percorso completo o il percorso relativo al file che si desidera caricare. In generale, è sempre meglio utilizzare un percorso relativo, in maniera tale che, se si copia la cartella di un progetto da un computer all’altro, tutto continua a funzionare.\nÈ una buona pratica impostare una determinata struttura di file con dati memorizzati in una cartella separata per ciascun progetto. Vediamo come si possa fare questo.\nCreare un progetto con RStudio\nCome indicato nell’esercizio 1 qui sotto, creiamo una cartella chiamata psicometria, dove salveremo tutti gli scritp Rmd che creeremo in questo corso. Una volta creata questa cartella, apriamo RStudio e creiamo un nuovo progetto. Per creare un progetto, da RStudio utilizziamo il percorso File/New Project... Quello che facciamo in questo modo è di comunicare ad R che questo specifico progetto è situato nella cartella di lavoro psicometria. L’indirizzo di questa cartella può essere ottenuto con l’istruzione getwd().\nPossiamo creare altre cartelle, dentro psicometria. Per esempio, creiamo da cartella data, dove salveremo i file di dati. Per fare un esercizio, utilizzeremo il file di dati wais.csv che può essere scaricato da Moodle. I dati in questo file corrispondono ai punteggi di quattro sottoscale della WAIS-IV completate da 90 studenti del corso di Psicometria dell’AA 2015/2016. Per fare un confronto, sappiamo che, nella popolazione, i punteggi di ciascuna sottoscala si distribuiscono normalmente con media 10 e deviazione standard 3.\nSalviamo questo file nella cartella data e poniamoci il problema di importare tali dati in R.\nImportare i dati in formato .csv\nPer leggere i dati contenuti in un file esterno, dobbiamo usare una funzione R capace di leggere i dati in quel formato e dobbiamo specificare dove si trova il file di dati che vogliamo importare. I dati sono conenuti del file wais.csv; dunque il file è in formato .csv. Per leggere i dati userò la funzione read_csv() e, per usare tale funzione, prima devo caricare il boundle di pacchetti tidyverse.\nDove si trova il file dei dati?\nOra si pone il problema di specificare dove si trova il file sul computer. È facile risolvere questo problema se abbiamo definito con R un progetto che identifica la cartella di lavoro che ci interessa.\nAvendo già creato il progetto psicometria, per specificare dove si trova il file che vogliamo importare possiamo utilizzare la funzione here::here(). Ovvero, rispetto alla cartella di lavoro che abbiamo definito, basta specificare in maniera relativa la cartella in cui abbiamo inserito il file. La sintassi da usare è la seguente:\n\n\nlibrary(\"here\")\nhere(\"data\", \"wais.csv\")\n\n\n[1] \"/Users/corrado/OneDrive - unifi.it/blog/data/wais.csv\"\n\nIn questo modo viene precisato l’indirizzo del file che voglio importare.\nPer importare i dati usiamo l’indirizzo specificato come indicato sopra:\n\n\nlibrary(\"tidyverse\")\ndf <- read_csv(here(\"data\", \"wais.csv\"))\n\n\n\nEsaminare i dati con glimpse()\nPossiamo esaminare il contenuto di df nel modo seguente:\n\n\nglimpse(df)\n\n\nRows: 90\nColumns: 7\n$ personal_code <chr> \"160996FMT784\", \"310795FMV569\", \"131096FSL143\"…\n$ MC            <dbl> 11, 9, 7, 5, 3, 7, 4, 8, 6, 13, 11, 9, 9, 9, 1…\n$ RA            <dbl> 11, 6, 11, 8, 9, 11, 7, 10, 3, 11, 9, 12, 9, 1…\n$ RS            <dbl> 12, 12, 12, 8, 9, 11, 12, 10, 14, 14, 11, 14, …\n$ CR            <dbl> 16, 14, 11, 10, 11, 13, 11, 14, 12, 17, 14, 12…\n$ wrkn_mem      <dbl> 22, 15, 18, 13, 12, 18, 11, 18, 9, 24, 20, 21,…\n$ pr_speed      <dbl> 28, 26, 23, 18, 20, 24, 23, 24, 26, 31, 25, 26…\n\nL’output di glimpse() ci comunica che ci sono 90 osservazioni e 7 variabili. I primi valori di ciascuna variabile vengono stampati. La funzione glimpse() ci dice anche quale classe di dati appartengono le variabili. Per esempio, personal_code appartiene alla classe char. Ciò vuol dire che le modalità di tale variabile sono delle stringhe alfanumeriche. Le altre varibili sono di type dbl, il che vuol dire che sono dei numeri reali.\nPossiamo anche esaminare i dati con la funzione head()\n\n\nhead(df)\n\n\n# A tibble: 6 x 7\n  personal_code    MC    RA    RS    CR wrkn_mem pr_speed\n  <chr>         <dbl> <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 160996FMT784     11    11    12    16       22       28\n2 310795FMV569      9     6    12    14       15       26\n3 131096FSL143      7    11    12    11       18       23\n4 230195FER172      5     8     8    10       13       18\n5 190396FCP941      3     9     9    11       12       20\n6 170896FMO879      7    11    11    13       18       24\n\noppure con summary()\n\n\nsummary(df)\n\n\n personal_code            MC               RA              RS       \n Length:90          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n                    NA's   :8        NA's   :8       NA's   :8      \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n NA's   :8       NA's   :8       NA's   :8      \n\nFormati diversi\nI dati possono essere in vari formati (Excel, SPSS, SAS, solo testo, RDS, …). Il pacchetto rio si pone l’obiettivo di semplificare il processo di importazione dei dati in R e l’esportazione dei dati da R. Dopo avere installato il pacchetto, install.packages(\"rio\"), lo carichiamo:\n\n\nlibrary(\"rio\")\n\n\n\nPer garantire che rio sia completamente funzionante, la prima volta che si usa rio eseguiamo la seguente istruzione:\n\n\ninstall_formats()\n\n\n\nA questo punto, importare i dati è molto semplice\n\n\ndf1 <- rio::import(here(\"data\", \"wais.csv\"))\n\n# confirm identical\nall.equal(df, df1, check.attributes = FALSE)\n\n\n[1] TRUE\n\nLeggiamo un file di dati in formato Excel:\n\n\ndf2 <- rio::import(here(\"data\", \"Jordan_etal.xls\"))\nglimpse(df2)\n\n\nRows: 747\nColumns: 50\n$ goodinfo           <dbl> 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,…\n$ condemn            <dbl> 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0,…\n$ qAnswered          <dbl> 16, 16, 16, 16, 16, 16, 4, 16, 16, 4, 16,…\n$ totalCorrect       <dbl> 16, 16, 16, 16, 16, 16, 3, 16, 16, 2, 16,…\n$ percCorrect        <dbl> 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.75,…\n$ ansall             <dbl> 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0,…\n$ dowork             <dbl> 4, 5, 2, 4, 3, 6, NA, 2, 2, NA, 1, NA, 4,…\n$ doromantic         <dbl> 2, 4, 1, 5, 5, 3, NA, 2, 2, NA, 1, NA, 4,…\n$ doacademic         <dbl> 2, 4, 5, 4, 3, 2, 3, 3, 2, NA, 2, NA, 4, …\n$ dodrugs            <dbl> 2, 5, 3, 3, 2, 3, NA, 3, 2, 4, 1, 4, 5, N…\n$ trustswork         <dbl> 5, 4, 5, 4, 5, 3, NA, 6, 6, NA, 7, NA, 5,…\n$ trustsromantic     <dbl> 3, 4, 6, 5, 4, 4, NA, 5, 5, NA, 7, NA, 5,…\n$ trustsacademic     <dbl> 5, 1, 5, 4, 5, 5, 5, 3, 5, NA, 5, NA, 6, …\n$ trustsdrugs        <dbl> 5, 5, 5, 4, 5, 5, NA, 5, 5, 3, 7, 4, 5, N…\n$ trustgwork         <dbl> 4, 4, 5, 4, 5, 2, NA, 5, 5, NA, 7, NA, 6,…\n$ trustgromantic     <dbl> 4, 5, 5, 4, 5, 2, NA, 5, 5, NA, 6, NA, 5,…\n$ trustgacademic     <dbl> 5, 3, 3, 4, 5, 5, 5, 3, 5, NA, 6, NA, 5, …\n$ trustgdrugs        <dbl> 5, 4, 3, 4, 5, 5, NA, 5, 5, 3, 5, 4, 4, N…\n$ likework           <dbl> 5, 4, 6, 4, 4, 3, NA, 5, 5, NA, 6, NA, 5,…\n$ likeromantic       <dbl> 3, 4, 7, 3, 5, 4, NA, 5, 5, NA, 7, NA, 5,…\n$ likeacademic       <dbl> 5, 4, 6, 4, 5, 6, 5, 4, 5, NA, 3, NA, 6, …\n$ likedrugs          <dbl> 5, 4, 4, 4, 4, 6, NA, 4, 5, 3, 6, 4, 4, N…\n$ compq1work         <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, NA, 2, NA, 2,…\n$ compq1romantic     <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, NA, 2, NA, 2,…\n$ compq1academic     <dbl> 2, 1, 2, 1, 1, 1, 2, 2, 1, NA, 2, NA, 2, …\n$ compq1drugs        <dbl> 2, 1, 2, 1, 1, 1, NA, 2, 1, 3, 2, 1, 2, N…\n$ compq2work         <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, NA, 1, NA, 1,…\n$ compq2romantic     <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, NA, 1, NA, 1,…\n$ compq2academic     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, 1, NA, 1, …\n$ compq2drugs        <dbl> 1, 1, 1, 1, 1, 1, NA, 1, 1, 2, 1, 1, 1, N…\n$ compq3work         <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, NA, 3, NA, 3,…\n$ compq3romantic     <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, NA, 3, NA, 3,…\n$ compq3academic     <dbl> 3, 3, 3, 3, 3, 3, 1, 3, 3, NA, 3, NA, 3, …\n$ compq3drugs        <dbl> 3, 3, 3, 3, 3, 3, NA, 3, 3, 3, 3, 1, 3, N…\n$ compq4work         <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, NA, 1, NA, 1,…\n$ compq4romantic     <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, NA, 1, NA, 1,…\n$ compq4academic     <dbl> 1, 2, 1, 1, 2, 2, 2, 2, 1, NA, 1, NA, 1, …\n$ compq4drugs        <dbl> 1, 2, 1, 1, 2, 2, NA, 2, 1, 1, 1, 2, 1, N…\n$ sumdo              <dbl> 5.50, 3.50, 5.25, 4.00, 4.75, 4.50, 5.00,…\n$ sumtrusts          <dbl> 4.50, 3.50, 5.25, 4.25, 4.75, 4.25, 5.00,…\n$ sumtrustg          <dbl> 4.50, 4.00, 4.00, 4.00, 5.00, 3.50, 5.00,…\n$ sumlike            <dbl> 4.50, 4.00, 5.75, 3.75, 4.50, 4.75, 5.00,…\n$ sumtotal           <dbl> 4.7500, 3.7500, 5.0625, 4.0000, 4.7500, 4…\n$ age                <dbl> 47, NA, 35, 38, 24, NA, NA, 29, 34, NA, 2…\n$ gender             <dbl> 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1,…\n$ edu                <dbl> 6, NA, 5, 4, 5, NA, NA, 6, 4, NA, 6, NA, …\n$ income             <dbl> 1, NA, 7, 7, 3, NA, NA, 4, 5, NA, 7, NA, …\n$ generaltrust       <dbl> 5, NA, 6, 1, 5, NA, NA, 6, 5, NA, 5, NA, …\n$ reason             <chr> \"Tried to balance or qualify the facts an…\n$ previousexperience <dbl> 3, NA, 2, 3, 2, NA, NA, 4, 3, NA, 1, NA, …\n\nEsportare i dati\nÈ possibile salvare i dati che abbiamo manipolato in R in un file esterno.\n\n\nrio::export(df2, \"jordan.csv\")\nrio::export(df2, \"jordan.rds\")\n\n\n\nSe adesso guardiamo nella cartella di lavoro dove stiamo lavorando, vedremo che sono stati creati i file jordan.csv e jordan.rds.\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] rio_0.5.26 forcats_0.5.1 stringr_1.4.0 dplyr_1.0.5\n[5] purrr_0.3.4 readr_1.4.0 tidyr_1.1.3 tibble_3.1.0\n[9] ggplot2_3.3.3 tidyverse_1.3.0 here_1.0.1\nloaded via a namespace (and not attached): [1] Rcpp_1.0.6 lubridate_1.7.10 assertthat_0.2.1\n[4] rprojroot_2.0.2 digest_0.6.27 utf8_1.1.4\n[7] R6_2.5.0 cellranger_1.1.0 backports_1.2.1\n[10] reprex_1.0.0 evaluate_0.14 httr_1.4.2\n[13] pillar_1.5.1 rlang_0.4.10 curl_4.3\n[16] readxl_1.3.1 rstudioapi_0.13 data.table_1.14.0\n[19] jquerylib_0.1.3 rmarkdown_2.7.3 foreign_0.8-75\n[22] munsell_0.5.0 broom_0.7.5 compiler_3.6.3\n[25] modelr_0.1.8 xfun_0.21 pkgconfig_2.0.3\n[28] htmltools_0.5.1.9000 downlit_0.2.1 tidyselect_1.1.0\n[31] fansi_0.4.2 crayon_1.4.1 dbplyr_2.1.0\n[34] withr_2.4.1 grid_3.6.3 jsonlite_1.7.2\n[37] gtable_0.3.0 lifecycle_1.0.0 DBI_1.1.1\n[40] magrittr_2.0.1 scales_1.1.1 zip_2.1.1\n[43] cli_2.3.1 stringi_1.5.3 debugme_1.1.0\n[46] fs_1.5.0 xml2_1.3.2 bslib_0.2.4\n[49] ellipsis_0.3.1 generics_0.1.0 vctrs_0.3.6\n[52] openxlsx_4.2.3 distill_1.2 tools_3.6.3\n[55] glue_1.4.2 hms_1.0.0 yaml_2.2.1\n[58] colorspace_2.0-0 rvest_1.0.0 knitr_1.31\n[61] haven_2.3.1 sass_0.3.1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-10T22:05:39+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-5/",
    "title": "Introduzione a R (5)",
    "description": "Il quinto post sulla sintassi di base di R: `tidyverse`.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nManipolazione dei dati\nSi chiamano “dati grezzi” quelli che provengono dal mondo circostanze, i dati raccolti per mezzo degli strumenti usati negli esperimenti, per mezzo di interviste, di questionari, ecc. Questi dati raramente vengono forniti con una struttura logica precisa. Per poterli elaborare mediante dei software dobbiamo prima trasformarli in maniera tale che abbiano una struttura logica organizzata. La struttura che solitamente si utilizza è quella tabellare (matrice dei dati), ovvero si dispongono i dati in una tabella nella quale a ciascuna riga corrisponde ad un’osservazione e ciascuna colonna corrisponde ad una variabile rilevata. In R una tale struttura è chiamata* data fram*e.\nIl pacchetto dplyr, che è al momento uno dei pacchetti più utilizzati per la gestione dei dati, offre una serie di funzionalità che consentono di ottenere il risultato descritto in precedenza e consente inoltre di eseguire le operazioni più comuni di manipolazione dei dati in maniera più semplice rispetto a quanto succeda quando usiamo le funzioni base di R.\ndplyr si fonda su cinque funzioni base:\nfilter(),\nselect(),\nmutate(),\narrange(),\nsummarise().\nA questi cinque comandi di base si aggiungono\nil pipe %>% che serve a concatenare più operazioni,\ngroup_by che viene utilizzato per il subsetting.\nIn particolare, considerando una matrice osservazioni per variabili (colonne), select() e mutate() si occupano di organizzare le variabili, filter() e arrange() i casi (righe), e summarise() i gruppi.\nPer introdurre le funzionalità di base di dplyr, usiamo i dati contenuti nel file sheffield.csv che può essere scaricato da Moodle. Carichiamo i pacchetti tidyverse e here:\n\n\nlibrary(\"tidyverse\")\nlibrary(\"here\")\n\n\n\nCreiamo l’oggetto df_sheffield leggendo da il file .csv nella working directory:\n\n\nlibrary(here)\ndf_sheffield <- read_csv(here(\"data\", \"sheffield.csv\"))\n\n\n\nCon l’istruzione here(\"data\", \"sheffield.csv\") ho specificato che, rispetto alla cartella di lavoro di default del progetto, il file si trova nella cartella data.\nI dati sono stati raccolti in una ricerca che ho eseguito un po’ di tempo fa sul problema della menzogna (Caudek, Lorenzino, & Liperoti, 2017). La teoria del carico cognitivo della menzogna ipotizza che mentire richieda un maggior carico cognitivo che dire la verità. In linea con questa ipotesi è stato dimostrato che le risposte menzognere sono tipicamente associate ad un innalzamento delle latenze di risposta rispetto alle risposte veritiere. Lo Sheffild Lie Test è una procedura comuterizzata che richiede ai soggetti di rispondere ad una serie di domande presentate sullo schermo in un ordine randomizzato. In metà delle prove ai soggetti viene chiesto di dire la verità e nell’altra metà di mentire. Il risultato tipico è che i tempi di reazione tendono ad essere maggiori quando ai soggetti viene chiesto di mentire piuttosto che di dire la verità.\nI dati contenuti nel file sheffield.csv riportano i tempi di reazione medi di 75 soggetti. Nel file sono contenute le seguenti variabili: lie indica se la consegna era di mentire o di dire la verità, self distingue le domande riferite al soggetto dalle domande riferite ad un estraneo, sex riporta il genere, age riporta l’età dei soggetti, pr_speed riporta i punteggi della scala WAIS relativa alla velocità di elaborazione, wrkn_mem riporta i punteggi della scala WAIS relativa alla memoria di lavoro, mrt riporta la media dei tempi di reazione.\nFiltrare le righe del data.frame con filter()\nLa funzione filter() consente di selezionare un sottoinsieme di osservazioni in un dataset. Per esempio, possiamo selezionare tutte le osservazioni nella variabile lie contrassegnate come yes e tutte le osservazioni nella variabile self contrassegnate come no:\n\n\ndf_sheffield %>% \n  dplyr::filter(lie == \"yes\", self == \"no\")\n\n\n# A tibble: 75 x 8\n      id lie   self  sex     age pr_speed wrkn_mem   mrt\n   <dbl> <chr> <chr> <chr> <dbl>    <dbl>    <dbl> <dbl>\n 1     1 yes   no    F        19       26       15 1454.\n 2     2 yes   no    F        20       23       18 1984.\n 3     3 yes   no    M        20       24       18 2760.\n 4     4 yes   no    F        19       23       11 1848.\n 5     5 yes   no    F        19       24       18 1810.\n 6     6 yes   no    F        19       26        9 2036.\n 7     7 yes   no    F        19       31       24 2292.\n 8     8 yes   no    F        20       25       20 1558.\n 9     9 yes   no    M        20       26       21 1589.\n10    10 yes   no    F        19       23       18 2136.\n# … with 65 more rows\n\nSelezionare le colonne del data.frame con select()\nLa funzione select() consente di selezionare un sottoinsieme di variabili in un dataset. Per esempio, possiamo selezionare solo le variabili id e mrt:\n\n\ndf_sheffield %>% \n  dplyr::select(id, mrt)\n\n\n# A tibble: 300 x 2\n      id   mrt\n   <dbl> <dbl>\n 1     1 1340.\n 2     1 1064.\n 3     1 1454.\n 4     1 1112.\n 5     2 1918.\n 6     2 1527.\n 7     2 1984.\n 8     2 1665.\n 9     3 2492.\n10     3 2186.\n# … with 290 more rows\n\nAggiungere una colonna al data.frame con mutate()\nTalvolta vogliamo creare una nuova variabile in uno stesso dataset ad esempio sommando o dividendo due variabili, oppure calcolandone la media. A questo scopo si usa la funzione mutate(). Per esempio, la somma dei punteggi di velocità di elaborazione pr_speed e di memoria di lavoro wrkn_mem della WAIS si trova come:\n\n\ndf <- df_sheffield %>%\n  mutate(\n    wais_sub = pr_speed + wrkn_mem\n  ) %>%\n  select(pr_speed, wrkn_mem, wais_sub)\nhead(df)\n\n\n# A tibble: 6 x 3\n  pr_speed wrkn_mem wais_sub\n     <dbl>    <dbl>    <dbl>\n1       26       15       41\n2       26       15       41\n3       26       15       41\n4       26       15       41\n5       23       18       41\n6       23       18       41\n\nOrdinare i dati con arrange()\nLa funzione arrange() serve a ordinare i dati in base ai valori di una o più variabili. Per esempio, possiamo ordinare la variabile mrt dal valore più alto al più basso in questo modo:\n\n\ndf_sheffield %>% \n  arrange(desc(mrt))\n\n\n# A tibble: 300 x 8\n      id lie   self  sex     age pr_speed wrkn_mem   mrt\n   <dbl> <chr> <chr> <chr> <dbl>    <dbl>    <dbl> <dbl>\n 1     3 yes   no    M        20       24       18 2760.\n 2     3 no    no    M        20       24       18 2492.\n 3     3 yes   yes   M        20       24       18 2389.\n 4    17 yes   no    F        23       21       15 2333.\n 5     7 yes   no    F        19       31       24 2292.\n 6    29 yes   no    F        19       22       18 2187.\n 7     3 no    yes   M        20       24       18 2186.\n 8    25 yes   no    F        19       28       19 2141.\n 9    10 yes   no    F        19       23       18 2136.\n10    73 yes   no    F        20       24       17 2082.\n# … with 290 more rows\n\nRaggruppare i dati con group_by()\nLa funzione group_by() serve a raggruppare insieme i valori in base a una o più variabili. La vedremo in uso in seguito insieme a summarise().\nSommario dei dati con summarise()\nLa funzione summarise() collassa il dataset in una singola riga dove viene riportato il risultato della statistica richiesta. Per esempio, la media dei tempi di reazione è\n\n\ndf_sheffield %>% \n  summarise(\n    y = mean(mrt, na.rm = TRUE) \n  )\n\n\n# A tibble: 1 x 1\n      y\n  <dbl>\n1 1443.\n\nCalcoliamo ora la media dei tempi di reazione in funzione delle variabili self e lie, ma solo per le femmine:\n\n\ndf_sheffield %>% \n  dplyr::filter(sex == \"F\") %>% \n  group_by(self, lie) %>% \n  summarise(\n    y = mean(mrt, na.rm = TRUE) \n  )\n\n\n# A tibble: 4 x 3\n# Groups:   self [2]\n  self  lie       y\n  <chr> <chr> <dbl>\n1 no    no    1445.\n2 no    yes   1694.\n3 yes   no    1197.\n4 yes   yes   1414.\n\nEsercizi\n1. Utilizziamo nuovamente i dati sulla menzogna discussi in precedenza.\nSi crei sul proprio computer una cartella chiamata psicometria.\nSi apra RStudio e si crei un nuovo progetto che ha psicometria come cartella di lavoro.\nNella cartella psicometria si creino delle altre cartelle. Una sarà chiamata data e in essa verranno salvati i file contenti i dati che utilizzeremo in questo corso. Altre cartelle avranno, ciascuna, il nome dell’argomento considerato. Ad esempio, se l’argomento trattato è probabilità potremmo creare una cartella con questo nome. Tuttavia, vi incoraggio a non usare mai caratteri speciali nel nome dei file e delle cartelle. Invece dello spazio potete usare il trattino basso. Gli accenti vanno eliminati. È più semplice (ed elegante) scrivere in inglese, così il problema non si pone. Quindi la cartella può essere chiamata probability. Considerate che R è sensibile alle maiuscole: probability e Probability non sono a stessa cosa!\nSi salvi il file sheffield.csv nella cartella data.\nUtilizzando la funzione here() del pacchetto here si specifichi dov’è il file sheffield.csv e si leggano i dati in R.\nSi generi un istogramma della variabile mrt che riporta la media dei tempi di reazione per ciascun soggetto in ciascuna condizione.\n2. Utilizzando gli stessi dati, si determini\nse in questo campione le femmine, in media, hanno valori più alti o più bassi dei maschi sulla variabile che codifica la velocità di elaborazione nella WAIS (pr_speed);\nse in questo campione le femmine, in media, hanno valori più alti o più bassi dei maschi sulla variabile che codifica la memoria di lavoro nella WAIS (wrkn_mem).\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] here_1.0.1 forcats_0.5.1 stringr_1.4.0 dplyr_1.0.4\n[5] purrr_0.3.4 readr_1.4.0 tidyr_1.1.2 tibble_3.1.0\n[9] ggplot2_3.3.3 tidyverse_1.3.0\nloaded via a namespace (and not attached): [1] tidyselect_1.1.0 xfun_0.21 bslib_0.2.4\n[4] haven_2.3.1 colorspace_2.0-0 vctrs_0.3.6\n[7] generics_0.1.0 htmltools_0.5.1.9000 yaml_2.2.1\n[10] utf8_1.1.4 rlang_0.4.10 jquerylib_0.1.3\n[13] pillar_1.5.1 withr_2.4.1 glue_1.4.2\n[16] DBI_1.1.1 dbplyr_2.1.0 modelr_0.1.8\n[19] readxl_1.3.1 lifecycle_1.0.0 munsell_0.5.0\n[22] gtable_0.3.0 cellranger_1.1.0 rvest_0.3.6\n[25] evaluate_0.14 knitr_1.31 fansi_0.4.2\n[28] broom_0.7.5 Rcpp_1.0.6 backports_1.2.1\n[31] scales_1.1.1 debugme_1.1.0 jsonlite_1.7.2\n[34] fs_1.5.0 distill_1.2 hms_1.0.0\n[37] digest_0.6.27 stringi_1.5.3 rprojroot_2.0.2\n[40] grid_3.6.3 cli_2.3.1 tools_3.6.3\n[43] magrittr_2.0.1 sass_0.3.1 crayon_1.4.1\n[46] pkgconfig_2.0.3 downlit_0.2.1 ellipsis_0.3.1\n[49] xml2_1.3.2 reprex_1.0.0 lubridate_1.7.9.2\n[52] rstudioapi_0.13 assertthat_0.2.1 rmarkdown_2.7.3\n[55] httr_1.4.2 R6_2.5.0 compiler_3.6.3\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-08T12:21:33+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-08-introduzione-a-r-6/",
    "title": "Introduzione a R (6)",
    "description": "Il sesto post sulla sintassi di base di R: `ggplot()`.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nCreare grafici con ggplot2\nLa visualizzazione si pone l’obiettivo di rappresentare i dati tramite linee, forme, colori e così via. Esiste una relazione strutturata, una mappatura, tra le variabili nei dati e la loro rappresentazione nel grafico visualizzato sullo schermo o sulla pagina. La funzione ggplot() fornisce una serie di strumenti per mappare i dati sugli elementi visivi del grafico, per specificare il tipo di grafico che si desidera ottenere e per controllare in modo preciso i dettagli di come le informazioni verranno visualizzate. Un ottimo approfondimento delle tematiche della visualizzazione si può trovare in Data visualizazion: a practical introduction di Kieran Healy.\nIl pacchetto ggplot2 fornisce un’implementazione della cosiddetta grammatica della grafica (grammar of graphics) di Wilkinson. Tale grammatica consiste in uno schema generale da applicare alla visualizzazione dei dati e permette di organizzare un grafico attraverso la combinazione di componenti semantiche distinte, come oggetti geometrici, scale e coordinate. Per questa ragione, in ggplot2 un grafico è costituito da una serie di strati (layers).\nNella visualizzazione è necessario specificare le connessioni tra le variabili nei dati e i colori, i punti e le forme che vengono rappresentate sullo schermo. In ggplot(), queste connessioni logiche tra i dati e gli elementi del grafico sono chiamate mappature estetiche, o semplicemente estetiche, e vengono specificate dalla funzione aes().\nLa funzione da cui si parte per inizializzare un grafico è ggplot(). Tale funzione richiede due argomenti: il primo è il data frame che contiene i dati da visualizzare; il secondo è la funzione aes() che specifica come le variabili nei dati si associano logicamente alle mappature estetiche del grafico.\nLa funzione aes() richiede di specificare x e y, ovvero i nomi delle colonne del data frame che rappresentano le variabili da porre rispettivamente sugli assi orizzontale e verticale.\nÈ poi necessario specificare il tipo di grafico che vogliamo costruire (ad esempio un grafico a dispersione, un grafico a scatola o un grafico a barre), aggiungendo all’oggetto creato da ggplot() tutte le componenti necessarie. In ggplot() la tipologia del grafico da costruire è chiamata geom(). Funzioni del tipo geom_...() vengono quindi usate per aggiungere al livello di base barre, linee, punti, e così via. Nello specifico, la tipologia del grafico viene specificata dalle seguenti funzioni:\ngeom_bar(): crea un grafico a barre;\ngeom_point(): crea un diagramma a dispersione;\ngeom_line(): crea un layer con una linea retta;\ngeom_histogram(): crea un istogramma;\ngeom_boxplot(): crea un box-plot;\ngeom_errorbar(): crea un grafico a barre che rappresenta gli intervalli di confidenza.\nInfine, tramite altre funzioni, ad esempio labs(), sarà possibile definire i dettagli più fini.\nUna generica istruzione ha la seguente forma:\n\n\nmy_graph <- \n  ggplot(my_data, aes(x_var, y_var)) +\n  geom_...()\n\n\n\nLa prima volta che si usa il pacchetto ggplot2 è necessario installarlo. Per fare questo possiamo installare tidyverse che, oltre a contenere ggplot2, fornisce altre utili funzioni per l’analisi dei dati. Per attivare il pacchetto tidyverse si usa l’istruzione:\n\n\nlibrary(\"tidyverse\")\n\n\n\nOgni volta che si inizia una sessione R è necessario attivare i pacchetti che si vogliono usare, ma non è necessario istallarli una nuova volta.  \nDiagramma a dispersione con la funzione geom_point()\nA titolo eseplificativo utilizzeremo il dataset msleep fornito dal pacchetto ggplot2 che descrive le ore di sonno medie di 83 specie di mammiferi. Poniamoci il problema di rappresentare graficamente la relazione tra il numero medio di ore di sonno giornaliero (sleep_total) e il peso dell’animale (bodywt) (Savage e West, 2007).\nInnanzitutto carichiamo i dati in R:\n\n\ndata(msleep)\n\n\n\nGeneriamo un diagramma a dispersione con le impostazioni di default di ggplot2:\n\n\np <- msleep %>%\n  ggplot(\n    aes(x = bodywt, y = sleep_total)\n  ) +\n  geom_point()\n\nprint(p)\n\n\n\n\nTramite la mappatura estetica geom_point() viene creato un diagramma a dispersione.\nPer visualizzare maggiori informazioni, coloriamo in maniera diversa i punti che rappresentano animali carnivori, erbivori, ecc. Tale risultato si ottiene specificando l’argomento col = nella funzione aes():\n\n\np <- msleep %>%\n  ggplot(\n    aes(\n      x = bodywt, y = sleep_total, col = vore\n    )\n  ) +\n  geom_point()\nprint(p)\n\n\n\n\nÈ chiaro, anche senza fare alcuna analisi statistica, che la relazione tra le due variabili non è lineare. Trasformando in maniera logaritmica i valori dell’asse x la relazione si linearizza.\n\n\np <- msleep %>%\n  ggplot(\n    aes(\n      x = log(bodywt), y = sleep_total, col = vore\n    )\n  ) +\n  geom_point()\nprint(p)\n\n\n\n\nCambiamo ora il tema del grafico, aggiungiamo le etichette sugli assi e il titolo. Per cambiare il tema del grafico, usiamo il cowplot con l’istruzione theme_set():\n\n\nlibrary(\"cowplot\")\ntheme_set(theme_cowplot())\n\nmsleep %>%\n  ggplot(\n    aes(x = log(bodywt), y = sleep_total, col = vore)\n  ) +\n  geom_point(size = 2) +\n  theme(legend.title = element_blank()) +\n  labs(\n    x = \"Log Peso Corporeo\",\n    y = \"Totale Ore di Sonno\",\n    title = \"Il sonno in 83 specie di mammiferi\", subtitle = \"Savage e West (2007)\"\n  )\n\n\n\n\nIstogramma con la funzione geom_histogram()\nCreiamo ora un istogramma che rappresenta la distribuzione del (logaritmo del) peso medio del cervello delle 83 specie di mammiferi considerate da Savage e West (2007).\n\n\nmsleep %>%\n  ggplot(\n    aes(log(brainwt))\n  ) +\n  geom_histogram(aes(y = ..density..)) +\n  labs(\n    x = \"Log Peso Cervello\",\n    y = \"Frequenza Relativa\"\n  ) +\n  theme(legend.title = element_blank())\n\n\n\n\nL’argomento aes(y=..density..) in geom_histogram() produce le frequenze relative. L’opzione di default (senza questo argomento) porta ggplot() a rappresentare le frequenze assolute.\nEsercizio con dati WAIS\nUtilizzando i dati contenuti nel file wais.csv, l’obiettivo è di esaminare la distribuzine dei punteggi Ricerca di simboli, separatamente per maschi e femmine. Tali distribuzioni condizionate possono essere visualizzate con un box plot. Prima di fare questo, però, è necessario trasformare e ricodificare i dati.\nLeggere i dati\nI valori riportati corrispondono ai punteggi di quattro sottoscale della WAIS-IV completate da 72 studenti del corso di Psicometria dell’AA 2015/2016. Nella popolazione, i punteggi di ciascuna sottoscala si distribuiscono normalmente con media 10 e deviazione standard 3.\nIniziamo a leggere i dati in R. Sul mio computer, i dati wais.csv sono contenuti della cartella data.\n\n\nlibrary(\"here\")\nlibrary(\"tidyverse\")\n\ntemp <- read_csv(here(\"data\", \"wais.csv\"))\nsummary(temp)\n\n\n personal_code            MC               RA              RS       \n Length:90          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n                    NA's   :8        NA's   :8       NA's   :8      \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n NA's   :8       NA's   :8       NA's   :8      \n\nElimino le osservazioni contenenti dati mancanti (codificati in R con NA).\n\n\ndf_wais <- temp[complete.cases(temp), ]\nsummary(df_wais)\n\n\n personal_code            MC               RA              RS       \n Length:82          Min.   : 3.000   Min.   : 3.00   Min.   : 3.00  \n Class :character   1st Qu.: 8.000   1st Qu.: 8.00   1st Qu.: 9.00  \n Mode  :character   Median : 9.000   Median : 9.00   Median :11.00  \n                    Mean   : 8.793   Mean   : 9.39   Mean   :10.91  \n                    3rd Qu.:10.000   3rd Qu.:11.00   3rd Qu.:12.00  \n                    Max.   :14.000   Max.   :17.00   Max.   :19.00  \n       CR           wrkn_mem        pr_speed    \n Min.   : 7.00   Min.   : 9.00   Min.   :14.00  \n 1st Qu.:11.00   1st Qu.:16.00   1st Qu.:20.00  \n Median :12.00   Median :18.00   Median :23.00  \n Mean   :12.34   Mean   :18.18   Mean   :23.26  \n 3rd Qu.:14.00   3rd Qu.:21.00   3rd Qu.:25.75  \n Max.   :17.00   Max.   :28.00   Max.   :36.00  \n\nPosso ora rimuovere l’oggetto temp:\n\n\nrm(temp)\n\n\n\nDefinisco la variabile ‘genere’\nDefinisco la variabile sex (genere) estraendo il settimo carattere da personal_code. Per fare questo uso la funzione substr(). La variabile sex viene poi trasformata in un fattore in quanto rappresenta una variabile qualitativa. Usando la funzione summary vediamo che ci sono 73 femmine e 9 maschi.\n\n\ndf_wais$sex <- substr(df_wais$personal_code, 7, 7)\ndf_wais$sex <- factor(df_wais$sex)\nsummary(df_wais$sex)\n\n\n F  M \n73  9 \n\nStatistiche descrittive condizionate alle modalità di una variabile categoriale\nEsaminiamo la media e la deviazione standard della variabile RS separatamente per maschi e femmine. Per fare questo, uso l’operatore “pipe” %>% che prende l’output di una funzione e lo trasforma nell’input della funzione successiva. Così, l’istruzione df_wais %>% significa: prendi il data frame df_wais (ovvero quello che viene prodotto quando la stringa df_wais viene digitata sullo schermo) e usalo come input per la funzione group_by. Tale funzione raggruppa i dati in funzione delle modalità della variabile sex, nel caso presente. Ovvero, tutte le manipolazioni che verranno effettuate sul data frame in seguito saranno fatte separatamente per le due modalità di sex. La pipe successiva passa questo input alla funzione summarise(), la quale consente di calcolare delle statistiche descrittive. Nel caso presente, la media mean() e la deviazione standard sd(), entrambe per la variabile RS. Nell’output che verrà prodotto, le medie dei punteggi RS per maschi e femmine costituiranno gli elementi di un vettore chiamato m; le deviazioni standard dei punteggi RS per maschi e femmine costituiranno gli elementi di un vettore chiamato std.\n\n\ndf_wais %>%\n  group_by(sex) %>%\n  summarise(\n    m = mean(RS),\n    std = sd(RS)\n  )\n\n\n# A tibble: 2 x 3\n  sex       m   std\n* <fct> <dbl> <dbl>\n1 F      10.8  2.87\n2 M      11.6  2.40\n\nBox plot con la funzione geom_boxplot()\nIl box plot fornisce una rappresetazione grafica della distribuzione di una variabile. In particolare, descrive visivamente la forma della distribuzione e la tendenza centrale (mediana). Nel grafico seguente viene riportato un boxplot separato per maschi e femmine. Usiamo ggplot() con la geom_boxplot():\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(x = sex, y = RS)\n  ) +\n  geom_boxplot()\nprint(p1)\n\n\n\n\nSovrapponiamo ai due boxplot i dati grezzi.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\")\nprint(p1)\n\n\n\n\nAggiungiamo le etichette a ciascun asse.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  )\nprint(p1)\n\n\n\n\nPoniamoci ora il problema di modificare le modalità della variabile sex. Per fare questo uso la funzione fct_recode contenuta nel pacchetto forcats. Si noti che la modalità della variabile che vogliamo cambiare si trova a destra dell’uguale, tra virgolette; la nuova modalità si trova a sinistra del segno di uguale, anch’essa tra virgolette.\n\n\nlibrary(\"forcats\")\ndf_wais <- df_wais %>%\n  mutate(\n    sex = fct_recode(\n      sex,\n      \"Femmmine\" = \"F\",\n      \"Maschi\" = \"M\"\n    )\n  )\n\n\n\nRifaccio ora il grafico dopo avere modificato il data frame.\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  ) \n\nprint(p1)\n\n\n\n\nPossiamo colorare il boxplot usando l’argomento fill = nella funzione aes():\n\n\np1 <- df_wais %>%\n  ggplot(\n    aes(sex, RS, fill = sex)\n  ) +\n  geom_boxplot() +\n  geom_jitter(width = 0.2, col = \"gray46\") +\n  labs(\n    title = \"Sottoscala RS della WAIS-IV in funzione del genere\",\n    subtitle = \"Campione di studenti di Psicometria\",\n    x = \"Genere\",\n    y = \"Ricerca di Simboli\"\n  ) +\n  theme(legend.position = \"none\")\n\nprint(p1)\n\n\n\n\nSession Info:\n\nR version 3.6.3 (2020-02-29) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.6\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\nlocale: [1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods\n[7] base\nother attached packages: [1] here_1.0.1 cowplot_1.1.1 forcats_0.5.1 stringr_1.4.0\n[5] dplyr_1.0.4 purrr_0.3.4 readr_1.4.0 tidyr_1.1.2\n[9] tibble_3.1.0 ggplot2_3.3.3 tidyverse_1.3.0\nloaded via a namespace (and not attached): [1] Rcpp_1.0.6 lubridate_1.7.9.2 assertthat_0.2.1\n[4] rprojroot_2.0.2 digest_0.6.27 utf8_1.1.4\n[7] R6_2.5.0 cellranger_1.1.0 backports_1.2.1\n[10] reprex_1.0.0 evaluate_0.14 httr_1.4.2\n[13] highr_0.8 pillar_1.5.1 rlang_0.4.10\n[16] readxl_1.3.1 rstudioapi_0.13 jquerylib_0.1.3\n[19] rmarkdown_2.7.3 labeling_0.4.2 munsell_0.5.0\n[22] broom_0.7.5 compiler_3.6.3 modelr_0.1.8\n[25] xfun_0.21 pkgconfig_2.0.3 htmltools_0.5.1.9000 [28] downlit_0.2.1 tidyselect_1.1.0 fansi_0.4.2\n[31] crayon_1.4.1 dbplyr_2.1.0 withr_2.4.1\n[34] grid_3.6.3 jsonlite_1.7.2 gtable_0.3.0\n[37] lifecycle_1.0.0 DBI_1.1.1 magrittr_2.0.1\n[40] scales_1.1.1 cli_2.3.1 stringi_1.5.3\n[43] debugme_1.1.0 farver_2.1.0 fs_1.5.0\n[46] xml2_1.3.2 bslib_0.2.4 ellipsis_0.3.1\n[49] generics_0.1.0 vctrs_0.3.6 distill_1.2\n[52] tools_3.6.3 glue_1.4.2 hms_1.0.0\n[55] yaml_2.2.1 colorspace_2.0-0 rvest_0.3.6\n[58] knitr_1.31 haven_2.3.1 sass_0.3.1\n\n\n\n\n",
    "preview": "posts/2021-03-08-introduzione-a-r-6/introduzione-a-r-6_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-03-08T12:27:20+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-03-08-istogramma/",
    "title": "Istogramma",
    "description": "La rappresentazione grafica della distribuzione dei dati.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-08",
    "categories": [
      "R",
      "Psicometria"
    ],
    "contents": "\nObiettivi di questo tutorial\nIn questo tutorial ci poniamo il problema di costruire un istrogramma utilizzando la funzione ggplot() del pacchetto ggplot2 in R. Vedremo quali sono i limiti degli istogrammi. Concluderemo introducendo una rappresentazione alternativa, la densità della frequenza dei dati, la quale attenua i limiti degli istogrammi.\nCarichiamo i pacchetti necessari\n\n\nsuppressPackageStartupMessages(library(\"tidyverse\")) \ntheme_set(bayesplot::theme_default(base_size=14))\nsuppressPackageStartupMessages(library(\"knitr\"))\nsuppressPackageStartupMessages(library(\"kableExtra\"))\nsuppressPackageStartupMessages(library(\"patchwork\"))\ntable_nums <- captioner::captioner(prefix = \"Tavola\")\nfigure_nums <- captioner::captioner(prefix = \"Figura\")\nknitr::opts_chunk$set(fig.align = \"center\", fig.width=7, fig.height=5)\n\n\n\nIntroduzione\nIniziamo con delle considerazioni di base.\nL’intervallo (a, b] si dice aperto a sinistra e chiuso a destra. Significa\n\\[\na < x \\leq b,\n\\]\novvero, descrive la situazione nella quale i valori che coincidono con il limite superiore dell’intervallo verranno inclusi nell’intervallo, mentre i valori che coincidono con il limte inferiore dell’intervanno non verranno inclusi nell’intervallo.\nConsideriamo questi dati:\n\n\nx <- c(1, 2, 1, 1, 5, 3, 2, 6)\n\n\n\nSupponiamo di volere i seguenti intervalli aperti a sinistra e chiusi a destra:\n(0, 2]\n(2, 4]\n(4, 6]\n(6, 8]\nPer la variabile x, la distribuzione di frequenze assolute diventa:\nIntervallo\nfrequenza\n(0, 2]\n5\n(2, 4]\n1\n(4, 6]\n2\n(6, 8]\n0\nSe invece consideriamo gli intervalli chiusi a sinistra e aperti a destra, [a, b), ovvero\n\\[\na \\leq x < b,\n\\]\nallora otteniamo una diversa distribuzione di frequenze assolute:\nIntervallo\nfrequenza\n[0, 2)\n3\n[2, 4)\n3\n[4, 6)\n1\n[6, 8)\n1\nUsiamo ora R per ottenere i risultati precedenti.\nUno dei modi possibili per calcolare le frequenze assolute è quello di usare la funzione cut(). Mediante tal funzione è possibile dividere il campo di variazione (ovvero, la differenza tra il valore massimo di una distribuzione ed il valore minimo) di una variabile continua x in intervalli e codificare ciascun valore x nei termini dell’intervallo a cui appartiene.\nIniziamo con gli intervalli aperti a sinistra e chiusi a destra:\n\n\nx_cat <- cut(\n  x,\n  breaks = c(0, 2, 4, 6, 8),\n  right = TRUE\n)\n\n\n\nPossiamo ora usare la funzione table() la quale ritorna una tabella con le frequenze assolute di ciascuna modalità della variabile in input.\n\n\ntable(x_cat)\n\n\nx_cat\n(0,2] (2,4] (4,6] (6,8] \n    5     1     2     0 \n\nLa distribuzione di frequenze per intervalli chiusi a sinistra e aperti a destra è:\n\n\nx_cat <- cut(\n  x,\n  breaks = c(0, 2, 4, 6, 8),\n  right = FALSE\n)\n\n\n\n\n\ntable(x_cat)\n\n\nx_cat\n[0,2) [2,4) [4,6) [6,8) \n    3     3     1     1 \n\nIstogramma\nCreiamo ora un istogramma usando i valori x.\nQual è l’altezza della barra in corrispondeza dell’intervallo (0,2]?\nLa base è pari a 2 e l’area è 5/8. Dunque l’altezza è\n\n\n(5/8) / 2\n\n\n[1] 0.3125\n\nUsiamo ggplot()\n\n\nx %>% \n  as.data.frame() %>% \n  ggplot(aes(x = x)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 2, 4, 6, 8) \n  ) \n\n\n\n\nQuesto ci conferma che, di default, ggplot() usa intervalli chiusi a destra.\nCambiamo ora il default e specifichiamo intervalli chiusi a sinistra:\n\n\nx %>% \n  as.data.frame() %>% \n  ggplot(aes(x = x)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 2, 4, 6, 8),\n    closed = \"left\"\n  ) \n\n\n\n\nManipolazione dei dati (importazione e pulizia)\nConsidereremo ora i dati di Zetsche, Bürkner, & Renneberg (2020) e ci poniamo il problema di descrivere la distribuzione dei punteggi BDI-II dei 67 partecipanti. Uno di essi non ha risposto e quindi c’è un dato mancante.\nCreiamo la varibile bdi che contiene i valori del valore BDI-II dei 66 soggetti:\n\n\nbysubj <- data.frame(\nbdi <- c(\n  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,\n  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3, 3,  5,  7,  9, 12, 19,\n  22, 22, 24, 25, 25, 26, 26, 26, 27, 27, 28, 28, 30, 30, 30, 31, 31, 33,\n  33, 34, 35, 35, 35, 36, 39, 41, 43, 43, 44\n  )\n)\n\n\n\nCalcolo delle frequenze assolute\nI seguenti cut-off vengono usati per interpretare il BDI‐II:\ndepressione minima = 0 – 13,\ndepressione lieve = 14 – 19,\ndepressione moderata = 20 – 28,\ndepressione severa = 29 – 63.\nCalcoliamo le frequenze assolute per i seguenti intervalli aperti a destra: [0, 13.5), [13.5, 19.5), [19.5, 28.5), [28.5, 63). Esaminando i dati, vediamo che 36 soggetti cadono nella prima classe. Dobbiamo però eseguire quest’operazione di conteggio utilizzando R.\n\n\nbysubj$bdi_level <- cut(\n  bysubj$bdi,\n  breaks = c(0, 13.5, 19.5, 28.5, 63),\n  include.lowest = TRUE,\n  labels = c(\n    \"minimal\", \"mild\", \"moderate\", \"severe\"\n  )\n)\n\nbysubj$bdi_level\n\n\n [1] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n [8] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[15] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[22] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[29] minimal  minimal  minimal  minimal  minimal  minimal  minimal \n[36] minimal  mild     moderate moderate moderate moderate moderate\n[43] moderate moderate moderate moderate moderate moderate moderate\n[50] severe   severe   severe   severe   severe   severe   severe  \n[57] severe   severe   severe   severe   severe   severe   severe  \n[64] severe   severe   severe  \nLevels: minimal mild moderate severe\n\n\n\ntable(bysubj$bdi_level)\n\n\n\n minimal     mild moderate   severe \n      36        1       12       17 \n\nPer ottenere le frequenze relative è sufficiente dividere ciascuna frequenza assoluta per il numero totale di osservazioni:\n\n\ntable(bysubj$bdi_level) / sum(table(bysubj$bdi_level))\n\n\n\n   minimal       mild   moderate     severe \n0.54545455 0.01515152 0.18181818 0.25757576 \n\nIn questo modo abbiamo ottenuto le distribuzioni di frequenza assoluta e relativa.\nLimiti delle classi\nFrequenza assoluta\nFrequenza relativa\n[0, 13.5)\n36\n36/66\n[13.5, 19.5)\n1\n1/66\n[19.5, 28.5)\n12\n12/66\n[28.5, 63]\n17\n17/66\nIstogramma\nL’istogramma delle frequenze assolute disegna un rettangolo sopra ogni intervallo specificato, la cui altezza corrisponde alla frequenza assoluta della classe. Per esempio, alla classe [0, 13.5] abbiamo associato la frequenza assoluta di 36. Nell’istogramma delle frequenze assolute l’altezza del primo rettangolo sarà dunque uguale a 36.\nNell’istogramma delle frequenze relative viene invece rappresentata la frequenza relativa delle classi: l’area di ogni rettangolo è proporzionale alla frequenza relativa della classe. Come si trova l’altezza delle barre dell’istogramma in tali circostanze? Per la classe [0, 13.5), ad esempio, la frequenza relativa è 36/66. Tale valore corrisponde all’area del rettangolo. Dato che la base del rettangolo è 13.5, l’altezza sarà 36/66 / 13.5, ovvero {r 36/66 / 13.5}. E così via per le altre barre dell’istogramma.\nVisualizzazione con ggplot()\n\n\n\n\n\np1 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = c(0, 13.5, 19.5, 28.5, 44.1) # il valore BDI-II massimo è 44\n  ) +\n  scale_x_continuous(breaks=c(0, 13.5, 19.5, 28.5, 44.1)) +\n  labs(\n    x = \"BDI-II\",\n    y = \"Densità di frequenza\"\n  )\np1\n\n\n\n\nFigure 1: Figura 1: Istogramma delle frequenze relative creato con ggplot().\n\n\n\nÈ più comune, però, utilizzare classi di ampiezza uguale.\n\n\n\n\n\np2 <- bysubj %>%\n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..),\n    breaks = seq(0, 44.1, length.out = 7)\n  ) +\n  scale_x_continuous(breaks=c(0.00,  7.35, 14.70, 22.05, 29.40, 36.75, 44.10)) +\n  labs(\n    x = \"BDI-II\",\n    y = \"Densità di frequenza\",\n    caption = \"Fonte: Zetsche, Buerkner, & Renneberg (2020)\"\n  )\n\n\n\n\n\np1 + p2\n\n\n\n\nLimite dell’istogramma\nCome abbiamo notato sopra, uno dei limiti degli istogrammi è che il profilo dell’istogramma è arbitrario: a seconda del numero e dei limiti delle classi che vengono scelte, cambiano sia il numero che la forma delle barre dell’istogramma.\nLa densità della frequenza dei dati\nIl problema precedente può essere alleviato utilizzando una rappresentazione alternativa della distribuzione di frequenza, ovvero la stima della densità della frequenza dei dati. Un modo semplice per pensare a tale rappresentazione, che in inglese va sotto il nome di density plot, è quello di immaginare un grande campione di dati, in modo che diventi possibile definire un enorme numero di classi di equivalenza di ampiezza molto piccola, le quali non risultino vuote. In tali circostanze, la funzione di densità empirica non è altro che il profilo `lisciato’ dell’istogramma. La stessa idea si applica anche quando il campione è più piccolo. Un esempio è fornito nella figura seguente.\n\n\n\n\n\np3 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_histogram(\n    aes(y = ..density..), \n    breaks = seq(0, 44.1, length.out = 7)\n  ) +\n  geom_density(\n    aes(x = bdi), \n    adjust = 0.5, \n    size = 0.8, \n    fill = \"steelblue3\", \n    alpha = 0.5\n  ) +\n  labs(\n    x = \"BDI-II\",\n    y = \"Densità di frequenza\"\n  )\np3\n\n\n\n\nFigure 2: Figura 3: Istogramma delle frequenze relative con sovrapposta la stima della densità della frequenza dei dati.\n\n\n\nGuardando il grafico della densità della frequenza dei dati possiamo notare che ci sono due valori che tendono a ricorrere più spesso nella distribuzione dei punteggi del BDI-II. Il primo valore tipico è di poco superiore allo zero. Il secondo valore tipico è all’incirca uguale a 25. Tali valori tipici si chiamano mode. Nel caso presente è sensato che una moda della distribuzione corrisponda ad un valore BDI-II molto basso, dato che il campione include 36 soggetti sani, e che una moda corrisponda ad un valore BDI-II di depressione moderata/severa, in quanto il campione include 30 soggetti clinicamente depressi. Ovviamente, se vogliamo rappresentare solo la densità della frequenza dei dati (senza l’istogramma) procediamo come indicato qui sotto.\n\n\n\n\n\np4 <- bysubj %>% \n  ggplot(aes(x = bdi)) +\n  geom_density(\n    aes(x = bdi), \n    adjust = 0.5, \n    size = 0.8, \n    fill = \"steelblue3\", \n    alpha = 0.5\n  ) +\n  labs(\n    x = \"BDI-II\",\n    y = \"Densità di frequenza\",\n    caption = \"Fonte: Zetsche, Buerkner, & Renneberg (2020)\"\n  )\np4\n\n\n\n\nFigure 3: Figura 4: Grafico della stima della densità della frequenza dei dati.\n\n\n\n\n\np3 + p4\n\n\n\n\nConclusioni\nL’area totale di un istogramma è pari a 1.0.\nQuando guardiamo un istogramma dobbiamo pensare che l’area di ciascuna barra è uguale alla frequenza relativa (ovvero alla proporzione) dei casi che cadono in quella classe.\nL’istogramma ci dice come si distribuiscono (proporzionalmente) le osservazioni di un campione nelle classi che sono state definite.\nIl fatto che l’area totale dell’istogramma sia unitaria significa che essa è la somma di tutte le proporzioni rappresentate dalla barre dell’istogramma.\nIl grafico della funzione di densità empirica attenua l’arbitrarietà della scelta del numero e della dimensione delle classi dell’istogramma e ci fornisce una rappresentazione grafica maggiormente comprensibile.\nOriginal Computing Environment\n\n\nsessionInfo()\n\n\nR version 3.6.3 (2020-02-29)\nPlatform: x86_64-apple-darwin15.6.0 (64-bit)\nRunning under: macOS Mojave 10.14.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] it_IT.UTF-8/it_IT.UTF-8/it_IT.UTF-8/C/it_IT.UTF-8/it_IT.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n [1] patchwork_1.1.1  kableExtra_1.3.4 knitr_1.31      \n [4] forcats_0.5.1    stringr_1.4.0    dplyr_1.0.5     \n [7] purrr_0.3.4      readr_1.4.0      tidyr_1.1.3     \n[10] tibble_3.1.0     ggplot2_3.3.3    tidyverse_1.3.0 \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.6           svglite_2.0.0        lubridate_1.7.10    \n [4] assertthat_0.2.1     digest_0.6.27        utf8_1.1.4          \n [7] R6_2.5.0             cellranger_1.1.0     plyr_1.8.6          \n[10] ggridges_0.5.3       backports_1.2.1      reprex_1.0.0        \n[13] evaluate_0.14        highr_0.8            httr_1.4.2          \n[16] pillar_1.5.1         rlang_0.4.10         readxl_1.3.1        \n[19] rstudioapi_0.13      jquerylib_0.1.3      rmarkdown_2.7.3     \n[22] labeling_0.4.2       webshot_0.5.2        munsell_0.5.0       \n[25] broom_0.7.5          compiler_3.6.3       modelr_0.1.8        \n[28] xfun_0.21            pkgconfig_2.0.3      systemfonts_1.0.1   \n[31] htmltools_0.5.1.9000 downlit_0.2.1        tidyselect_1.1.0    \n[34] viridisLite_0.3.0    fansi_0.4.2          crayon_1.4.1        \n[37] dbplyr_2.1.0         withr_2.4.1          grid_3.6.3          \n[40] jsonlite_1.7.2       gtable_0.3.0         lifecycle_1.0.0     \n[43] DBI_1.1.1            magrittr_2.0.1       scales_1.1.1        \n[46] cli_2.3.1            stringi_1.5.3        debugme_1.1.0       \n[49] farver_2.1.0         fs_1.5.0             xml2_1.3.2          \n[52] bslib_0.2.4          ellipsis_0.3.1       generics_0.1.0      \n[55] vctrs_0.3.6          distill_1.2          captioner_2.2.3     \n[58] tools_3.6.3          glue_1.4.2           hms_1.0.0           \n[61] yaml_2.2.1           colorspace_2.0-0     bayesplot_1.8.0     \n[64] rvest_1.0.0          haven_2.3.1          sass_0.3.1          \n\n\n\n\n",
    "preview": "posts/2021-03-08-istogramma/preview.png",
    "last_modified": "2021-03-12T10:02:53+01:00",
    "input_file": {},
    "preview_width": 1020,
    "preview_height": 762
  },
  {
    "path": "posts/2021-03-07-bibliografia/",
    "title": "Le citazioni",
    "description": "Bibliografia della prova finale e della tesi di laurea magistrale.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "tesi"
    ],
    "contents": "\nHo creato un breve video con le istruzioni per creare la bibliografia delle tesi di laurea. Ci sono tanti tutorial sul web per affrontare questo problema: le semplici considerazioni che fornisco qui sono un possibile punto di partenza.\nAl di là delle cose che dico qui, consiglio fortemente tutti i laureandi, triennali e magistrali, di scrivere la tesi di laurea in R Markdown, usando le indicazioni fornite in un altro post e, soprattutto, di utilizzare bibtex per la bibliografia, in modo tale essere sicuri di ottenere il risultato corretto senza doversi preoccupare di applicare le (complicate) regole APA – i ricercatori fanno così quando scrivono un articolo.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-07T21:30:05+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-07-istruzioniprovafinalel24/",
    "title": "Istruzioni per la prova finale L-24",
    "description": "Tutto quello che avreste sempre voluto sapere sulla stesura dell'elaborato finale e non avete mai osato chiedere.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "tesi"
    ],
    "contents": "\nMediante questo link potete accedere ad un video in cui rispondo a tutte le possibili domande che potreste avere su questo argomento. Descriverò la procedura che consiglio per realizzare l’elaborato finale e per preparare la presentazione orale. Una volta scritto l’elaborato finale seguendo queste istruzioni, potete iniziare a lavorare alla presentazione orale. Sulla presentazione orale riceverete poi altri feedback negli incontri settimanali con i laureandi che saranno specificamente dedicati a questo tema.\n\n\n\n",
    "preview": "posts/2021-03-07-istruzioniprovafinalel24/preview.png",
    "last_modified": "2021-03-13T12:01:37+01:00",
    "input_file": {},
    "preview_width": 1034,
    "preview_height": 736
  },
  {
    "path": "posts/2021-03-07-pagina-facebook/",
    "title": "Pagina facebook",
    "description": "Social media.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "social media"
    ],
    "contents": "\nÈ attiva la pagina facebook del laboratorio. Contiene informazioni su progetti in corso e presentazioni dei laureandi. È una creazione dei torocinanti del laboratorio.\n\n\n\n",
    "preview": "posts/2021-03-07-pagina-facebook/preview.png",
    "last_modified": "2021-03-13T12:06:19+01:00",
    "input_file": {},
    "preview_width": 522,
    "preview_height": 840
  },
  {
    "path": "posts/2021-03-07-scrivere-la-tesi-con-r-markdown/",
    "title": "Scrivere la tesi con R Markdown",
    "description": "Video tutorial sull'uso di R Markdown per la tesi di laurea.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "R",
      "tesi"
    ],
    "contents": "\nSeguendo questo link potete trovare un video-tutorial sull’uso di R Markdown per la scrittura della tesi di laurea. Il materiale che ho predisposto può essere scaricato selezionando questo link. Buon lavoro!\n\n\n\n",
    "preview": "posts/2021-03-07-scrivere-la-tesi-con-r-markdown/preview.png",
    "last_modified": "2021-03-13T12:11:55+01:00",
    "input_file": {},
    "preview_width": 664,
    "preview_height": 644
  },
  {
    "path": "posts/welcome/",
    "title": "L'inizio",
    "description": "Benvenuti nel mio blog.",
    "author": [
      {
        "name": "Corrado Caudek",
        "url": "https://caudekblog.netlify.app"
      }
    ],
    "date": "2021-03-07",
    "categories": [
      "social media"
    ],
    "contents": "\nIl blog è scritto in R Markdown usando le funzioni del pacchetto distill. Ho seguito le istruzioni contenute in Building a blog with distill e Creating a Blog.\n\n\n\n",
    "preview": "posts/welcome/preview.png",
    "last_modified": "2021-03-13T12:14:13+01:00",
    "input_file": {},
    "preview_width": 596,
    "preview_height": 422
  }
]
